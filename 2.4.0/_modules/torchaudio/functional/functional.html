


<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>torchaudio.functional.functional &mdash; Torchaudio 2.4.0 documentation</title>
  

  
  
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <!-- <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" /> -->
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/katex-math.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/sg_gallery.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/sg_gallery-binder.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/sg_gallery-dataframe.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/sg_gallery-rendered-html.css" type="text/css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-beta/dist/katex.min.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/css/custom.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
  <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-T8XT4PS');</script>
    <!-- End Google Tag Manager -->
  

  
  <script src="../../../_static/js/modernizr.min.js"></script>

  <!-- Preload the theme fonts -->

<link rel="preload" href="../../../_static/fonts/FreightSans/freight-sans-book.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="../../../_static/fonts/FreightSans/freight-sans-medium.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="../../../_static/fonts/IBMPlexMono/IBMPlexMono-Medium.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="../../../_static/fonts/FreightSans/freight-sans-bold.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="../../../_static/fonts/FreightSans/freight-sans-medium-italic.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="../../../_static/fonts/IBMPlexMono/IBMPlexMono-SemiBold.woff2" as="font" type="font/woff2" crossorigin="anonymous">

<!-- Preload the katex fonts -->

<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Math-Italic.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Main-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Main-Bold.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Size1-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Size4-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Size2-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Size3-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Caligraphic-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css" integrity="sha384-vSIIfh2YWi9wW0r9iZe7RJPrKwp6bG+s9QZMoITbCckVJqGCCRhc+ccxNcdpHuYu" crossorigin="anonymous">
</head>

<div class="container-fluid header-holder tutorials-header" id="header-holder">
  <div class="container">
    <div class="header-container">
      <a class="header-logo" href="https://pytorch.org/" aria-label="PyTorch"></a>

      <div class="main-menu">
        <ul>
          <li>
            <a href="https://pytorch.org/get-started">Get Started</a>
          </li>

          <li>
            <a href="https://pytorch.org/ecosystem">Ecosystem</a>
          </li>

          <li>
            <a href="https://pytorch.org/mobile">Mobile</a>
          </li>

          <li>
            <a href="https://pytorch.org/blog/">Blog</a>
          </li>

          <li>
            <a href="https://pytorch.org/tutorials">Tutorials</a>
          </li>

          <li>
            <div id="resourcesDropdownButton" data-toggle="resources-dropdown" class="resources-dropdown">
              <a class="resource-option with-down-orange-arrow">
                Docs
              </a>
              <div class="resources-dropdown-menu">
                <a class="doc-dropdown-option nav-dropdown-item" href="https://pytorch.org/docs/stable/index.html">
                  <span class="dropdown-title">PyTorch</span>
                  <p></p>
                </a>
                <a class="doc-dropdown-option nav-dropdown-item" href="https://pytorch.org/audio/stable/index.html">
                  <span class="dropdown-title">torchaudio</span>
                  <p></p>
                </a>
                <a class="doc-dropdown-option nav-dropdown-item" href="https://pytorch.org/text/stable/index.html">
                  <span class="dropdown-title">torchtext</span>
                  <p></p>
                </a>
                <a class="doc-dropdown-option nav-dropdown-item" href="https://pytorch.org/vision/stable/index.html">
                  <span class="dropdown-title">torchvision</span>
                  <p></p>
                </a>
                <a class="doc-dropdown-option nav-dropdown-item" href="https://pytorch.org/torcharrow">
                  <span class="dropdown-title">torcharrow</span>
                  <p></p>
                </a>
                <a class="doc-dropdown-option nav-dropdown-item" href="https://pytorch.org/data">
                  <span class="dropdown-title">TorchData</span>
                  <p></p>
                </a>
                <a class="doc-dropdown-option nav-dropdown-item" href="https://pytorch.org/torchrec">
                  <span class="dropdown-title">TorchRec</span>
                  <p></p>
                </a>
                <a class="doc-dropdown-option nav-dropdown-item" href="https://pytorch.org/serve/">
                  <span class="dropdown-title">TorchServe</span>
                  <p></p>
                </a>
                <a class="doc-dropdown-option nav-dropdown-item" href="https://pytorch.org/torchx/">
                  <span class="dropdown-title">TorchX</span>
                  <p></p>
                </a>
                <a class="doc-dropdown-option nav-dropdown-item" href="https://pytorch.org/xla">
                  <span class="dropdown-title">PyTorch on XLA Devices</span>
                  <p></p>
                </a>
            </div>
          </li>

          <li>
            <div id="resourcesDropdownButton" data-toggle="resources-dropdown" class="resources-dropdown">
              <a class="resource-option with-down-arrow">
                Resources
              </a>
              <div class="resources-dropdown-menu">
                <a class="nav-dropdown-item" href="https://pytorch.org/features">
                  <span class="dropdown-title">About</span>
                  <p>Learn about PyTorchâ€™s features and capabilities</p>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/foundation">
                  <span class="dropdown-title">PyTorch Foundation</span>
                  <p>Learn about the PyTorch foundation</p>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/#community-module">
                  <span class="dropdown-title">Community</span>
                  <p>Join the PyTorch developer community to contribute, learn, and get your questions answered.</p>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/community-stories">
                  <span class="dropdown-title">Community Stories</span>
                  <p>Learn how our community solves real, everyday machine learning problems with PyTorch.</p>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/resources">
                  <span class="dropdown-title">Developer Resources</span>
                  <p>Find resources and get questions answered</p>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/events">
                  <span class="dropdown-title">Events</span>
                  <p>Find events, webinars, and podcasts</p>
                </a>
                <a class="nav-dropdown-item" href="https://discuss.pytorch.org/" target="_blank">
                  <span class="dropdown-title">Forums</span>
                  <p>A place to discuss PyTorch code, issues, install, research</p>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/hub">
                  <span class="dropdown-title">Models (Beta)</span>
                  <p>Discover, publish, and reuse pre-trained models</p>
                </a>
              </div>
            </div>
          </li>

          <li>
            <a href="https://github.com/pytorch/pytorch">GitHub</a>
          </li>
        </ul>
      </div>

      <a class="main-menu-open-button" href="#" data-behavior="open-mobile-menu"></a>
    </div>
  </div>
</div>

<body class="pytorch-body">

   

    

    <div class="table-of-contents-link-wrapper">
      <span>Table of Contents</span>
      <a href="#" class="toggle-table-of-contents" data-behavior="toggle-table-of-contents"></a>
    </div>

    <nav data-toggle="wy-nav-shift" class="pytorch-left-menu" id="pytorch-left-menu">
      <div class="pytorch-side-scroll">
        <div class="pytorch-menu pytorch-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          <div class="pytorch-left-menu-search">
            
    <div class="version">
      <a href="../../../../versions.html"><span style="font-size:110%">2.4.0 &#x25BC</span></a>
    </div>
    


  


<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search Docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          </div>

          
            
            
              
            
            
              <p class="caption" role="heading"><span class="caption-text">Torchaudio Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../index.html">Index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../supported_features.html">Supported Features</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../feature_classifications.html">Feature Classifications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../logo.html">TorchAudio Logo</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../references.html">References</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Installation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installing pre-built binaries</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../build.html">Building from source</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../build.linux.html">Building on Linux and macOS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../build.windows.html">Building on Windows</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../build.jetson.html">Building on Jetson</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../build.ffmpeg.html">Enabling GPU video decoder/encoder</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Tutorials</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/audio_io_tutorial.html">Audio I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/streamreader_basic_tutorial.html">StreamReader Basic Usages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/streamreader_advanced_tutorial.html">StreamReader Advanced Usages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/streamwriter_basic_tutorial.html">StreamWriter Basic Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/streamwriter_advanced.html">StreamWriter Advanced Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/nvdec_tutorial.html">Accelerated video decoding with NVDEC</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/nvenc_tutorial.html">Accelerated video encoding with NVENC</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/effector_tutorial.html">AudioEffector Usages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/audio_resampling_tutorial.html">Audio Resampling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/audio_data_augmentation_tutorial.html">Audio Data Augmentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/audio_feature_extractions_tutorial.html">Audio Feature Extractions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/audio_feature_augmentation_tutorial.html">Audio Feature Augmentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/ctc_forced_alignment_api_tutorial.html">CTC forced alignment API tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/oscillator_tutorial.html">Oscillator and ADSR envelope</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/additive_synthesis_tutorial.html">Additive Synthesis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/filter_design_tutorial.html">Filter design tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/subtractive_synthesis_tutorial.html">Subtractive synthesis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/audio_datasets_tutorial.html">Audio Datasets</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Pipeline Tutorials</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/speech_recognition_pipeline_tutorial.html">Speech Recognition with Wav2Vec2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/asr_inference_with_ctc_decoder_tutorial.html">ASR Inference with CTC Decoder</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/asr_inference_with_cuda_ctc_decoder_tutorial.html">ASR Inference with CUDA CTC Decoder</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/online_asr_tutorial.html">Online ASR with Emformer RNN-T</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/device_asr.html">Device ASR with Emformer RNN-T</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/device_avsr.html">Device AV-ASR with Emformer RNN-T</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/forced_alignment_tutorial.html">Forced Alignment with Wav2Vec2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/forced_alignment_for_multilingual_data_tutorial.html">Forced alignment for multilingual data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/tacotron2_pipeline_tutorial.html">Text-to-Speech with Tacotron2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/mvdr_tutorial.html">Speech Enhancement with MVDR Beamforming</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/hybrid_demucs_tutorial.html">Music Source Separation with Hybrid Demucs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/squim_tutorial.html">Torchaudio-Squim: Non-intrusive Speech Assessment in TorchAudio</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Training Recipes</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://github.com/pytorch/audio/tree/main/examples/asr/librispeech_conformer_rnnt">Conformer RNN-T ASR</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/pytorch/audio/tree/main/examples/asr/emformer_rnnt">Emformer RNN-T ASR</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/pytorch/audio/tree/main/examples/source_separation">Conv-TasNet Source Separation</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/pytorch/audio/tree/main/examples/hubert">HuBERT Pre-training and Fine-tuning (ASR)</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/pytorch/audio/tree/main/examples/avsr">Real-time AV-ASR</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Python API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../torchaudio.html">torchaudio</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../io.html">torchaudio.io</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../functional.html">torchaudio.functional</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../transforms.html">torchaudio.transforms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../datasets.html">torchaudio.datasets</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../models.html">torchaudio.models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../models.decoder.html">torchaudio.models.decoder</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../pipelines.html">torchaudio.pipelines</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sox_effects.html">torchaudio.sox_effects</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../compliance.kaldi.html">torchaudio.compliance.kaldi</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../kaldi_io.html">torchaudio.kaldi_io</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../utils.html">torchaudio.utils</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../torio.html">torio</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../torio.io.html">torio.io</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../torio.utils.html">torio.utils</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Python Prototype API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../prototype.html">torchaudio.prototype</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../prototype.datasets.html">torchaudio.prototype.datasets</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../prototype.functional.html">torchaudio.prototype.functional</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../prototype.models.html">torchaudio.prototype.models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../prototype.pipelines.html">torchaudio.prototype.pipelines</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../prototype.transforms.html">torchaudio.prototype.transforms</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">C++ Prototype API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../libtorio.html">libtorio</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../libtorio.stream_reader.html">torio::io::StreamingMediaDecoder</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../libtorio.stream_writer.html">torio::io::StreamingMediaEncoder</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">PyTorch Libraries</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://pytorch.org/docs">PyTorch</a></li>
<li class="toctree-l1"><a class="reference external" href="https://pytorch.org/audio">torchaudio</a></li>
<li class="toctree-l1"><a class="reference external" href="https://pytorch.org/text">torchtext</a></li>
<li class="toctree-l1"><a class="reference external" href="https://pytorch.org/vision">torchvision</a></li>
<li class="toctree-l1"><a class="reference external" href="https://pytorch.org/elastic/">TorchElastic</a></li>
<li class="toctree-l1"><a class="reference external" href="https://pytorch.org/serve">TorchServe</a></li>
<li class="toctree-l1"><a class="reference external" href="http://pytorch.org/xla/">PyTorch on XLA Devices</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <div class="pytorch-container">
      <div class="pytorch-page-level-bar" id="pytorch-page-level-bar">
        <div class="pytorch-breadcrumbs-wrapper">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="pytorch-breadcrumbs">
    
      <li>
        <a href="../../../index.html">
          
            Docs
          
        </a> &gt;
      </li>

        
          <li><a href="../../index.html">Module code</a> &gt;</li>
        
      <li>torchaudio.functional.functional &gt;</li>
      
      <li>Old version (stable)</li>
      
    
    
      <li class="pytorch-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
</div>
        </div>

        <div class="pytorch-shortcuts-wrapper" id="pytorch-shortcuts-wrapper">
          Shortcuts
        </div>
      </div>

      <section data-toggle="wy-nav-shift" id="pytorch-content-wrap" class="pytorch-content-wrap">
        <div class="pytorch-content-left">

        
    
    
          <!-- Google Tag Manager (noscript) -->
          <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-T8XT4PS"
          height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
          <!-- End Google Tag Manager (noscript) -->
          
          <div class="rst-content">
          
            <div role="main" class="main-content" itemscope="itemscope" itemtype="http://schema.org/Article">
             <article itemprop="articleBody" id="pytorch-article" class="pytorch-article">
              
  <h1>Source code for torchaudio.functional.functional</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>

<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">tempfile</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Sequence</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">torchaudio</span>
<span class="kn">from</span> <span class="nn">torch</span> <span class="kn">import</span> <span class="n">Tensor</span>
<span class="kn">from</span> <span class="nn">torchaudio._internal.module_utils</span> <span class="kn">import</span> <span class="n">deprecated</span>

<span class="kn">from</span> <span class="nn">.filtering</span> <span class="kn">import</span> <span class="n">highpass_biquad</span><span class="p">,</span> <span class="n">treble_biquad</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;spectrogram&quot;</span><span class="p">,</span>
    <span class="s2">&quot;inverse_spectrogram&quot;</span><span class="p">,</span>
    <span class="s2">&quot;griffinlim&quot;</span><span class="p">,</span>
    <span class="s2">&quot;amplitude_to_DB&quot;</span><span class="p">,</span>
    <span class="s2">&quot;DB_to_amplitude&quot;</span><span class="p">,</span>
    <span class="s2">&quot;compute_deltas&quot;</span><span class="p">,</span>
    <span class="s2">&quot;melscale_fbanks&quot;</span><span class="p">,</span>
    <span class="s2">&quot;linear_fbanks&quot;</span><span class="p">,</span>
    <span class="s2">&quot;create_dct&quot;</span><span class="p">,</span>
    <span class="s2">&quot;compute_deltas&quot;</span><span class="p">,</span>
    <span class="s2">&quot;detect_pitch_frequency&quot;</span><span class="p">,</span>
    <span class="s2">&quot;DB_to_amplitude&quot;</span><span class="p">,</span>
    <span class="s2">&quot;mu_law_encoding&quot;</span><span class="p">,</span>
    <span class="s2">&quot;mu_law_decoding&quot;</span><span class="p">,</span>
    <span class="s2">&quot;phase_vocoder&quot;</span><span class="p">,</span>
    <span class="s2">&quot;mask_along_axis&quot;</span><span class="p">,</span>
    <span class="s2">&quot;mask_along_axis_iid&quot;</span><span class="p">,</span>
    <span class="s2">&quot;sliding_window_cmn&quot;</span><span class="p">,</span>
    <span class="s2">&quot;spectral_centroid&quot;</span><span class="p">,</span>
    <span class="s2">&quot;apply_codec&quot;</span><span class="p">,</span>
    <span class="s2">&quot;resample&quot;</span><span class="p">,</span>
    <span class="s2">&quot;edit_distance&quot;</span><span class="p">,</span>
    <span class="s2">&quot;loudness&quot;</span><span class="p">,</span>
    <span class="s2">&quot;pitch_shift&quot;</span><span class="p">,</span>
    <span class="s2">&quot;rnnt_loss&quot;</span><span class="p">,</span>
    <span class="s2">&quot;psd&quot;</span><span class="p">,</span>
    <span class="s2">&quot;mvdr_weights_souden&quot;</span><span class="p">,</span>
    <span class="s2">&quot;mvdr_weights_rtf&quot;</span><span class="p">,</span>
    <span class="s2">&quot;rtf_evd&quot;</span><span class="p">,</span>
    <span class="s2">&quot;rtf_power&quot;</span><span class="p">,</span>
    <span class="s2">&quot;apply_beamforming&quot;</span><span class="p">,</span>
    <span class="s2">&quot;fftconvolve&quot;</span><span class="p">,</span>
    <span class="s2">&quot;convolve&quot;</span><span class="p">,</span>
    <span class="s2">&quot;add_noise&quot;</span><span class="p">,</span>
    <span class="s2">&quot;speed&quot;</span><span class="p">,</span>
    <span class="s2">&quot;preemphasis&quot;</span><span class="p">,</span>
    <span class="s2">&quot;deemphasis&quot;</span><span class="p">,</span>
<span class="p">]</span>


<div class="viewcode-block" id="spectrogram"><a class="viewcode-back" href="../../../generated/torchaudio.functional.spectrogram.html#torchaudio.functional.spectrogram">[docs]</a><span class="k">def</span> <span class="nf">spectrogram</span><span class="p">(</span>
    <span class="n">waveform</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
    <span class="n">pad</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">window</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
    <span class="n">n_fft</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">hop_length</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">win_length</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">power</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
    <span class="n">normalized</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span>
    <span class="n">center</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">pad_mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;reflect&quot;</span><span class="p">,</span>
    <span class="n">onesided</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">return_complex</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Create a spectrogram or a batch of spectrograms from a raw audio signal.</span>
<span class="sd">    The spectrogram can be either magnitude-only or complex.</span>

<span class="sd">    .. devices:: CPU CUDA</span>

<span class="sd">    .. properties:: Autograd TorchScript</span>

<span class="sd">    Args:</span>
<span class="sd">        waveform (Tensor): Tensor of audio of dimension `(..., time)`</span>
<span class="sd">        pad (int): Two sided padding of signal</span>
<span class="sd">        window (Tensor): Window tensor that is applied/multiplied to each frame/window</span>
<span class="sd">        n_fft (int): Size of FFT</span>
<span class="sd">        hop_length (int): Length of hop between STFT windows</span>
<span class="sd">        win_length (int): Window size</span>
<span class="sd">        power (float or None): Exponent for the magnitude spectrogram,</span>
<span class="sd">            (must be &gt; 0) e.g., 1 for magnitude, 2 for power, etc.</span>
<span class="sd">            If None, then the complex spectrum is returned instead.</span>
<span class="sd">        normalized (bool or str): Whether to normalize by magnitude after stft. If input is str, choices are</span>
<span class="sd">            ``&quot;window&quot;`` and ``&quot;frame_length&quot;``, if specific normalization type is desirable. ``True`` maps to</span>
<span class="sd">            ``&quot;window&quot;``. When normalized on ``&quot;window&quot;``, waveform is normalized upon the window&#39;s L2 energy. If</span>
<span class="sd">            normalized on ``&quot;frame_length&quot;``, waveform is normalized by dividing by</span>
<span class="sd">            :math:`(\text{frame\_length})^{0.5}`.</span>
<span class="sd">        center (bool, optional): whether to pad :attr:`waveform` on both sides so</span>
<span class="sd">            that the :math:`t`-th frame is centered at time :math:`t \times \text{hop\_length}`.</span>
<span class="sd">            Default: ``True``</span>
<span class="sd">        pad_mode (string, optional): controls the padding method used when</span>
<span class="sd">            :attr:`center` is ``True``. Default: ``&quot;reflect&quot;``</span>
<span class="sd">        onesided (bool, optional): controls whether to return half of results to</span>
<span class="sd">            avoid redundancy. Default: ``True``</span>
<span class="sd">        return_complex (bool, optional):</span>
<span class="sd">            Deprecated and not used.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tensor: Dimension `(..., freq, time)`, freq is</span>
<span class="sd">        ``n_fft // 2 + 1`` and ``n_fft`` is the number of</span>
<span class="sd">        Fourier bins, and time is the number of window hops (n_frame).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">return_complex</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;`return_complex` argument is now deprecated and is not effective.&quot;</span>
            <span class="s2">&quot;`torchaudio.functional.spectrogram(power=None)` always returns a tensor with &quot;</span>
            <span class="s2">&quot;complex dtype. Please remove the argument in the function call.&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">pad</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># TODO add &quot;with torch.no_grad():&quot; back when JIT supports it</span>
        <span class="n">waveform</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">functional</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">waveform</span><span class="p">,</span> <span class="p">(</span><span class="n">pad</span><span class="p">,</span> <span class="n">pad</span><span class="p">),</span> <span class="s2">&quot;constant&quot;</span><span class="p">)</span>

    <span class="n">frame_length_norm</span><span class="p">,</span> <span class="n">window_norm</span> <span class="o">=</span> <span class="n">_get_spec_norms</span><span class="p">(</span><span class="n">normalized</span><span class="p">)</span>

    <span class="c1"># pack batch</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">waveform</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
    <span class="n">waveform</span> <span class="o">=</span> <span class="n">waveform</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="c1"># default values are consistent with librosa.core.spectrum._spectrogram</span>
    <span class="n">spec_f</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stft</span><span class="p">(</span>
        <span class="nb">input</span><span class="o">=</span><span class="n">waveform</span><span class="p">,</span>
        <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span>
        <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span>
        <span class="n">win_length</span><span class="o">=</span><span class="n">win_length</span><span class="p">,</span>
        <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
        <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span>
        <span class="n">pad_mode</span><span class="o">=</span><span class="n">pad_mode</span><span class="p">,</span>
        <span class="n">normalized</span><span class="o">=</span><span class="n">frame_length_norm</span><span class="p">,</span>
        <span class="n">onesided</span><span class="o">=</span><span class="n">onesided</span><span class="p">,</span>
        <span class="n">return_complex</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># unpack batch</span>
    <span class="n">spec_f</span> <span class="o">=</span> <span class="n">spec_f</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">spec_f</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:])</span>

    <span class="k">if</span> <span class="n">window_norm</span><span class="p">:</span>
        <span class="n">spec_f</span> <span class="o">/=</span> <span class="n">window</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">sqrt</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">power</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">power</span> <span class="o">==</span> <span class="mf">1.0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">spec_f</span><span class="o">.</span><span class="n">abs</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">spec_f</span><span class="o">.</span><span class="n">abs</span><span class="p">()</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="n">power</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">spec_f</span></div>


<div class="viewcode-block" id="inverse_spectrogram"><a class="viewcode-back" href="../../../generated/torchaudio.functional.inverse_spectrogram.html#torchaudio.functional.inverse_spectrogram">[docs]</a><span class="k">def</span> <span class="nf">inverse_spectrogram</span><span class="p">(</span>
    <span class="n">spectrogram</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
    <span class="n">length</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="n">pad</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">window</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
    <span class="n">n_fft</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">hop_length</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">win_length</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">normalized</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span>
    <span class="n">center</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">pad_mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;reflect&quot;</span><span class="p">,</span>
    <span class="n">onesided</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Create an inverse spectrogram or a batch of inverse spectrograms from the provided</span>
<span class="sd">    complex-valued spectrogram.</span>

<span class="sd">    .. devices:: CPU CUDA</span>

<span class="sd">    .. properties:: Autograd TorchScript</span>

<span class="sd">    Args:</span>
<span class="sd">        spectrogram (Tensor): Complex tensor of audio of dimension (..., freq, time).</span>
<span class="sd">        length (int or None): The output length of the waveform.</span>
<span class="sd">        pad (int): Two sided padding of signal. It is only effective when ``length`` is provided.</span>
<span class="sd">        window (Tensor): Window tensor that is applied/multiplied to each frame/window</span>
<span class="sd">        n_fft (int): Size of FFT</span>
<span class="sd">        hop_length (int): Length of hop between STFT windows</span>
<span class="sd">        win_length (int): Window size</span>
<span class="sd">        normalized (bool or str): Whether the stft output was normalized by magnitude. If input is str, choices are</span>
<span class="sd">            ``&quot;window&quot;`` and ``&quot;frame_length&quot;``, dependent on normalization mode. ``True`` maps to</span>
<span class="sd">            ``&quot;window&quot;``.</span>
<span class="sd">        center (bool, optional): whether the waveform was padded on both sides so</span>
<span class="sd">            that the :math:`t`-th frame is centered at time :math:`t \times \text{hop\_length}`.</span>
<span class="sd">            Default: ``True``</span>
<span class="sd">        pad_mode (string, optional): controls the padding method used when</span>
<span class="sd">            :attr:`center` is ``True``. This parameter is provided for compatibility with the</span>
<span class="sd">            spectrogram function and is not used. Default: ``&quot;reflect&quot;``</span>
<span class="sd">        onesided (bool, optional): controls whether spectrogram was done in onesided mode.</span>
<span class="sd">            Default: ``True``</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tensor: Dimension `(..., time)`. Least squares estimation of the original signal.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">frame_length_norm</span><span class="p">,</span> <span class="n">window_norm</span> <span class="o">=</span> <span class="n">_get_spec_norms</span><span class="p">(</span><span class="n">normalized</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">spectrogram</span><span class="o">.</span><span class="n">is_complex</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expected `spectrogram` to be complex dtype.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">window_norm</span><span class="p">:</span>
        <span class="n">spectrogram</span> <span class="o">=</span> <span class="n">spectrogram</span> <span class="o">*</span> <span class="n">window</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">sqrt</span><span class="p">()</span>

    <span class="c1"># pack batch</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">spectrogram</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
    <span class="n">spectrogram</span> <span class="o">=</span> <span class="n">spectrogram</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="c1"># default values are consistent with librosa.core.spectrum._spectrogram</span>
    <span class="n">waveform</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">istft</span><span class="p">(</span>
        <span class="nb">input</span><span class="o">=</span><span class="n">spectrogram</span><span class="p">,</span>
        <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span>
        <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span>
        <span class="n">win_length</span><span class="o">=</span><span class="n">win_length</span><span class="p">,</span>
        <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
        <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span>
        <span class="n">normalized</span><span class="o">=</span><span class="n">frame_length_norm</span><span class="p">,</span>
        <span class="n">onesided</span><span class="o">=</span><span class="n">onesided</span><span class="p">,</span>
        <span class="n">length</span><span class="o">=</span><span class="n">length</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">pad</span> <span class="k">if</span> <span class="n">length</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">return_complex</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">length</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">pad</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># remove padding from front and back</span>
        <span class="n">waveform</span> <span class="o">=</span> <span class="n">waveform</span><span class="p">[:,</span> <span class="n">pad</span><span class="p">:</span><span class="o">-</span><span class="n">pad</span><span class="p">]</span>

    <span class="c1"># unpack batch</span>
    <span class="n">waveform</span> <span class="o">=</span> <span class="n">waveform</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">waveform</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:])</span>

    <span class="k">return</span> <span class="n">waveform</span></div>


<span class="k">def</span> <span class="nf">_get_spec_norms</span><span class="p">(</span><span class="n">normalized</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]):</span>
    <span class="n">frame_length_norm</span><span class="p">,</span> <span class="n">window_norm</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">jit</span><span class="o">.</span><span class="n">isinstance</span><span class="p">(</span><span class="n">normalized</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">normalized</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;frame_length&quot;</span><span class="p">,</span> <span class="s2">&quot;window&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid normalized parameter: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">normalized</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">normalized</span> <span class="o">==</span> <span class="s2">&quot;frame_length&quot;</span><span class="p">:</span>
            <span class="n">frame_length_norm</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">normalized</span> <span class="o">==</span> <span class="s2">&quot;window&quot;</span><span class="p">:</span>
            <span class="n">window_norm</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">elif</span> <span class="n">torch</span><span class="o">.</span><span class="n">jit</span><span class="o">.</span><span class="n">isinstance</span><span class="p">(</span><span class="n">normalized</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">normalized</span><span class="p">:</span>
            <span class="n">window_norm</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Input type not supported&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">frame_length_norm</span><span class="p">,</span> <span class="n">window_norm</span>


<span class="k">def</span> <span class="nf">_get_complex_dtype</span><span class="p">(</span><span class="n">real_dtype</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">real_dtype</span> <span class="o">==</span> <span class="n">torch</span><span class="o">.</span><span class="n">double</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">cdouble</span>
    <span class="k">if</span> <span class="n">real_dtype</span> <span class="o">==</span> <span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">cfloat</span>
    <span class="k">if</span> <span class="n">real_dtype</span> <span class="o">==</span> <span class="n">torch</span><span class="o">.</span><span class="n">half</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">complex32</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unexpected dtype </span><span class="si">{</span><span class="n">real_dtype</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="griffinlim"><a class="viewcode-back" href="../../../generated/torchaudio.functional.griffinlim.html#torchaudio.functional.griffinlim">[docs]</a><span class="k">def</span> <span class="nf">griffinlim</span><span class="p">(</span>
    <span class="n">specgram</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
    <span class="n">window</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
    <span class="n">n_fft</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">hop_length</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">win_length</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">power</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">n_iter</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">momentum</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">length</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="n">rand_init</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Compute waveform from a linear scale magnitude spectrogram using the Griffin-Lim transformation.</span>

<span class="sd">    .. devices:: CPU CUDA</span>

<span class="sd">    .. properties:: Autograd TorchScript</span>

<span class="sd">    Implementation ported from</span>
<span class="sd">    *librosa* :cite:`brian_mcfee-proc-scipy-2015`, *A fast Griffin-Lim algorithm* :cite:`6701851`</span>
<span class="sd">    and *Signal estimation from modified short-time Fourier transform* :cite:`1172092`.</span>

<span class="sd">    Args:</span>
<span class="sd">        specgram (Tensor): A magnitude-only STFT spectrogram of dimension `(..., freq, frames)`</span>
<span class="sd">            where freq is ``n_fft // 2 + 1``.</span>
<span class="sd">        window (Tensor): Window tensor that is applied/multiplied to each frame/window</span>
<span class="sd">        n_fft (int): Size of FFT, creates ``n_fft // 2 + 1`` bins</span>
<span class="sd">        hop_length (int): Length of hop between STFT windows. (</span>
<span class="sd">            Default: ``win_length // 2``)</span>
<span class="sd">        win_length (int): Window size. (Default: ``n_fft``)</span>
<span class="sd">        power (float): Exponent for the magnitude spectrogram,</span>
<span class="sd">            (must be &gt; 0) e.g., 1 for magnitude, 2 for power, etc.</span>
<span class="sd">        n_iter (int): Number of iteration for phase recovery process.</span>
<span class="sd">        momentum (float): The momentum parameter for fast Griffin-Lim.</span>
<span class="sd">            Setting this to 0 recovers the original Griffin-Lim method.</span>
<span class="sd">            Values near 1 can lead to faster convergence, but above 1 may not converge.</span>
<span class="sd">        length (int or None): Array length of the expected output.</span>
<span class="sd">        rand_init (bool): Initializes phase randomly if True, to zero otherwise.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tensor: waveform of `(..., time)`, where time equals the ``length`` parameter if given.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">momentum</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;momentum must be in range [0, 1). Found: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">momentum</span><span class="p">))</span>

    <span class="n">momentum</span> <span class="o">=</span> <span class="n">momentum</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">momentum</span><span class="p">)</span>

    <span class="c1"># pack batch</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">specgram</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
    <span class="n">specgram</span> <span class="o">=</span> <span class="n">specgram</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]))</span>

    <span class="n">specgram</span> <span class="o">=</span> <span class="n">specgram</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">power</span><span class="p">)</span>

    <span class="c1"># initialize the phase</span>
    <span class="k">if</span> <span class="n">rand_init</span><span class="p">:</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">specgram</span><span class="o">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">_get_complex_dtype</span><span class="p">(</span><span class="n">specgram</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span> <span class="n">device</span><span class="o">=</span><span class="n">specgram</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">specgram</span><span class="o">.</span><span class="n">size</span><span class="p">(),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">_get_complex_dtype</span><span class="p">(</span><span class="n">specgram</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span> <span class="n">device</span><span class="o">=</span><span class="n">specgram</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

    <span class="c1"># And initialize the previous iterate to 0</span>
    <span class="n">tprev</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">specgram</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">specgram</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_iter</span><span class="p">):</span>
        <span class="c1"># Invert with our current estimate of the phases</span>
        <span class="n">inverse</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">istft</span><span class="p">(</span>
            <span class="n">specgram</span> <span class="o">*</span> <span class="n">angles</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span> <span class="n">win_length</span><span class="o">=</span><span class="n">win_length</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="n">length</span>
        <span class="p">)</span>

        <span class="c1"># Rebuild the spectrogram</span>
        <span class="n">rebuilt</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stft</span><span class="p">(</span>
            <span class="nb">input</span><span class="o">=</span><span class="n">inverse</span><span class="p">,</span>
            <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span>
            <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span>
            <span class="n">win_length</span><span class="o">=</span><span class="n">win_length</span><span class="p">,</span>
            <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
            <span class="n">center</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">pad_mode</span><span class="o">=</span><span class="s2">&quot;reflect&quot;</span><span class="p">,</span>
            <span class="n">normalized</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">onesided</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">return_complex</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Update our phase estimates</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">rebuilt</span>
        <span class="k">if</span> <span class="n">momentum</span><span class="p">:</span>
            <span class="n">angles</span> <span class="o">=</span> <span class="n">angles</span> <span class="o">-</span> <span class="n">tprev</span><span class="o">.</span><span class="n">mul_</span><span class="p">(</span><span class="n">momentum</span><span class="p">)</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">angles</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="n">angles</span><span class="o">.</span><span class="n">abs</span><span class="p">()</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mf">1e-16</span><span class="p">))</span>

        <span class="c1"># Store the previous iterate</span>
        <span class="n">tprev</span> <span class="o">=</span> <span class="n">rebuilt</span>

    <span class="c1"># Return the final phase estimates</span>
    <span class="n">waveform</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">istft</span><span class="p">(</span>
        <span class="n">specgram</span> <span class="o">*</span> <span class="n">angles</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span> <span class="n">win_length</span><span class="o">=</span><span class="n">win_length</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="n">length</span>
    <span class="p">)</span>

    <span class="c1"># unpack batch</span>
    <span class="n">waveform</span> <span class="o">=</span> <span class="n">waveform</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">waveform</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:])</span>

    <span class="k">return</span> <span class="n">waveform</span></div>


<div class="viewcode-block" id="amplitude_to_DB"><a class="viewcode-back" href="../../../generated/torchaudio.functional.amplitude_to_DB.html#torchaudio.functional.amplitude_to_DB">[docs]</a><span class="k">def</span> <span class="nf">amplitude_to_DB</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">multiplier</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">amin</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">db_multiplier</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">top_db</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Turn a spectrogram from the power/amplitude scale to the decibel scale.</span>

<span class="sd">    .. devices:: CPU CUDA</span>

<span class="sd">    .. properties:: Autograd TorchScript</span>

<span class="sd">    The output of each tensor in a batch depends on the maximum value of that tensor,</span>
<span class="sd">    and so may return different values for an audio clip split into snippets vs. a full clip.</span>

<span class="sd">    Args:</span>

<span class="sd">        x (Tensor): Input spectrogram(s) before being converted to decibel scale.</span>
<span class="sd">            The expected shapes are ``(freq, time)``, ``(channel, freq, time)`` or</span>
<span class="sd">            ``(..., batch, channel, freq, time)``.</span>

<span class="sd">            .. note::</span>

<span class="sd">               When ``top_db`` is specified, cut-off values are computed for each audio</span>
<span class="sd">               in the batch. Therefore if the input shape is 4D (or larger), different</span>
<span class="sd">               cut-off values are used for audio data in the batch.</span>
<span class="sd">               If the input shape is 2D or 3D, a single cutoff value is used.</span>

<span class="sd">        multiplier (float): Use 10. for power and 20. for amplitude</span>
<span class="sd">        amin (float): Number to clamp ``x``</span>
<span class="sd">        db_multiplier (float): Log10(max(reference value and amin))</span>
<span class="sd">        top_db (float or None, optional): Minimum negative cut-off in decibels. A reasonable number</span>
<span class="sd">            is 80. (Default: ``None``)</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tensor: Output tensor in decibel scale</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x_db</span> <span class="o">=</span> <span class="n">multiplier</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">clamp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">min</span><span class="o">=</span><span class="n">amin</span><span class="p">))</span>
    <span class="n">x_db</span> <span class="o">-=</span> <span class="n">multiplier</span> <span class="o">*</span> <span class="n">db_multiplier</span>

    <span class="k">if</span> <span class="n">top_db</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Expand batch</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">x_db</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
        <span class="n">packed_channels</span> <span class="o">=</span> <span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span> <span class="k">if</span> <span class="n">x_db</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="n">x_db</span> <span class="o">=</span> <span class="n">x_db</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">packed_channels</span><span class="p">,</span> <span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">x_db</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x_db</span><span class="p">,</span> <span class="p">(</span><span class="n">x_db</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">-</span> <span class="n">top_db</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="c1"># Repack batch</span>
        <span class="n">x_db</span> <span class="o">=</span> <span class="n">x_db</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">x_db</span></div>


<div class="viewcode-block" id="DB_to_amplitude"><a class="viewcode-back" href="../../../generated/torchaudio.functional.DB_to_amplitude.html#torchaudio.functional.DB_to_amplitude">[docs]</a><span class="k">def</span> <span class="nf">DB_to_amplitude</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">ref</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">power</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Turn a tensor from the decibel scale to the power/amplitude scale.</span>

<span class="sd">    .. devices:: CPU CUDA</span>

<span class="sd">    .. properties:: TorchScript</span>

<span class="sd">    Args:</span>
<span class="sd">        x (Tensor): Input tensor before being converted to power/amplitude scale.</span>
<span class="sd">        ref (float): Reference which the output will be scaled by.</span>
<span class="sd">        power (float): If power equals 1, will compute DB to power. If 0.5, will compute DB to amplitude.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tensor: Output tensor in power/amplitude scale.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ref</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="mf">10.0</span><span class="p">,</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="n">x</span><span class="p">),</span> <span class="n">power</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_hz_to_mel</span><span class="p">(</span><span class="n">freq</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">mel_scale</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;htk&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Convert Hz to Mels.</span>

<span class="sd">    Args:</span>
<span class="sd">        freqs (float): Frequencies in Hz</span>
<span class="sd">        mel_scale (str, optional): Scale to use: ``htk`` or ``slaney``. (Default: ``htk``)</span>

<span class="sd">    Returns:</span>
<span class="sd">        mels (float): Frequency in Mels</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">mel_scale</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;slaney&quot;</span><span class="p">,</span> <span class="s2">&quot;htk&quot;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;mel_scale should be one of &quot;htk&quot; or &quot;slaney&quot;.&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">mel_scale</span> <span class="o">==</span> <span class="s2">&quot;htk&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">2595.0</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="p">(</span><span class="n">freq</span> <span class="o">/</span> <span class="mf">700.0</span><span class="p">))</span>

    <span class="c1"># Fill in the linear part</span>
    <span class="n">f_min</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">f_sp</span> <span class="o">=</span> <span class="mf">200.0</span> <span class="o">/</span> <span class="mi">3</span>

    <span class="n">mels</span> <span class="o">=</span> <span class="p">(</span><span class="n">freq</span> <span class="o">-</span> <span class="n">f_min</span><span class="p">)</span> <span class="o">/</span> <span class="n">f_sp</span>

    <span class="c1"># Fill in the log-scale part</span>
    <span class="n">min_log_hz</span> <span class="o">=</span> <span class="mf">1000.0</span>
    <span class="n">min_log_mel</span> <span class="o">=</span> <span class="p">(</span><span class="n">min_log_hz</span> <span class="o">-</span> <span class="n">f_min</span><span class="p">)</span> <span class="o">/</span> <span class="n">f_sp</span>
    <span class="n">logstep</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">6.4</span><span class="p">)</span> <span class="o">/</span> <span class="mf">27.0</span>

    <span class="k">if</span> <span class="n">freq</span> <span class="o">&gt;=</span> <span class="n">min_log_hz</span><span class="p">:</span>
        <span class="n">mels</span> <span class="o">=</span> <span class="n">min_log_mel</span> <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">freq</span> <span class="o">/</span> <span class="n">min_log_hz</span><span class="p">)</span> <span class="o">/</span> <span class="n">logstep</span>

    <span class="k">return</span> <span class="n">mels</span>


<span class="k">def</span> <span class="nf">_mel_to_hz</span><span class="p">(</span><span class="n">mels</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">mel_scale</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;htk&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert mel bin numbers to frequencies.</span>

<span class="sd">    Args:</span>
<span class="sd">        mels (Tensor): Mel frequencies</span>
<span class="sd">        mel_scale (str, optional): Scale to use: ``htk`` or ``slaney``. (Default: ``htk``)</span>

<span class="sd">    Returns:</span>
<span class="sd">        freqs (Tensor): Mels converted in Hz</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">mel_scale</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;slaney&quot;</span><span class="p">,</span> <span class="s2">&quot;htk&quot;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;mel_scale should be one of &quot;htk&quot; or &quot;slaney&quot;.&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">mel_scale</span> <span class="o">==</span> <span class="s2">&quot;htk&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">700.0</span> <span class="o">*</span> <span class="p">(</span><span class="mf">10.0</span> <span class="o">**</span> <span class="p">(</span><span class="n">mels</span> <span class="o">/</span> <span class="mf">2595.0</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span>

    <span class="c1"># Fill in the linear scale</span>
    <span class="n">f_min</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">f_sp</span> <span class="o">=</span> <span class="mf">200.0</span> <span class="o">/</span> <span class="mi">3</span>
    <span class="n">freqs</span> <span class="o">=</span> <span class="n">f_min</span> <span class="o">+</span> <span class="n">f_sp</span> <span class="o">*</span> <span class="n">mels</span>

    <span class="c1"># And now the nonlinear scale</span>
    <span class="n">min_log_hz</span> <span class="o">=</span> <span class="mf">1000.0</span>
    <span class="n">min_log_mel</span> <span class="o">=</span> <span class="p">(</span><span class="n">min_log_hz</span> <span class="o">-</span> <span class="n">f_min</span><span class="p">)</span> <span class="o">/</span> <span class="n">f_sp</span>
    <span class="n">logstep</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">6.4</span><span class="p">)</span> <span class="o">/</span> <span class="mf">27.0</span>

    <span class="n">log_t</span> <span class="o">=</span> <span class="n">mels</span> <span class="o">&gt;=</span> <span class="n">min_log_mel</span>
    <span class="n">freqs</span><span class="p">[</span><span class="n">log_t</span><span class="p">]</span> <span class="o">=</span> <span class="n">min_log_hz</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">logstep</span> <span class="o">*</span> <span class="p">(</span><span class="n">mels</span><span class="p">[</span><span class="n">log_t</span><span class="p">]</span> <span class="o">-</span> <span class="n">min_log_mel</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">freqs</span>


<span class="k">def</span> <span class="nf">_create_triangular_filterbank</span><span class="p">(</span>
    <span class="n">all_freqs</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
    <span class="n">f_pts</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a triangular filter bank.</span>

<span class="sd">    Args:</span>
<span class="sd">        all_freqs (Tensor): STFT freq points of size (`n_freqs`).</span>
<span class="sd">        f_pts (Tensor): Filter mid points of size (`n_filter`).</span>

<span class="sd">    Returns:</span>
<span class="sd">        fb (Tensor): The filter bank of size (`n_freqs`, `n_filter`).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Adopted from Librosa</span>
    <span class="c1"># calculate the difference between each filter mid point and each stft freq point in hertz</span>
    <span class="n">f_diff</span> <span class="o">=</span> <span class="n">f_pts</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">f_pts</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># (n_filter + 1)</span>
    <span class="n">slopes</span> <span class="o">=</span> <span class="n">f_pts</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">all_freqs</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># (n_freqs, n_filter + 2)</span>
    <span class="c1"># create overlapping triangles</span>
    <span class="n">zero</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">down_slopes</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">slopes</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="n">f_diff</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># (n_freqs, n_filter)</span>
    <span class="n">up_slopes</span> <span class="o">=</span> <span class="n">slopes</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:]</span> <span class="o">/</span> <span class="n">f_diff</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>  <span class="c1"># (n_freqs, n_filter)</span>
    <span class="n">fb</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">zero</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">down_slopes</span><span class="p">,</span> <span class="n">up_slopes</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">fb</span>


<div class="viewcode-block" id="melscale_fbanks"><a class="viewcode-back" href="../../../generated/torchaudio.functional.melscale_fbanks.html#torchaudio.functional.melscale_fbanks">[docs]</a><span class="k">def</span> <span class="nf">melscale_fbanks</span><span class="p">(</span>
    <span class="n">n_freqs</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">f_min</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">f_max</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">n_mels</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">sample_rate</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">norm</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">mel_scale</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;htk&quot;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Create a frequency bin conversion matrix.</span>

<span class="sd">    .. devices:: CPU</span>

<span class="sd">    .. properties:: TorchScript</span>

<span class="sd">    Note:</span>
<span class="sd">        For the sake of the numerical compatibility with librosa, not all the coefficients</span>
<span class="sd">        in the resulting filter bank has magnitude of 1.</span>

<span class="sd">        .. image:: https://download.pytorch.org/torchaudio/doc-assets/mel_fbanks.png</span>
<span class="sd">           :alt: Visualization of generated filter bank</span>

<span class="sd">    Args:</span>
<span class="sd">        n_freqs (int): Number of frequencies to highlight/apply</span>
<span class="sd">        f_min (float): Minimum frequency (Hz)</span>
<span class="sd">        f_max (float): Maximum frequency (Hz)</span>
<span class="sd">        n_mels (int): Number of mel filterbanks</span>
<span class="sd">        sample_rate (int): Sample rate of the audio waveform</span>
<span class="sd">        norm (str or None, optional): If &quot;slaney&quot;, divide the triangular mel weights by the width of the mel band</span>
<span class="sd">            (area normalization). (Default: ``None``)</span>
<span class="sd">        mel_scale (str, optional): Scale to use: ``htk`` or ``slaney``. (Default: ``htk``)</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tensor: Triangular filter banks (fb matrix) of size (``n_freqs``, ``n_mels``)</span>
<span class="sd">        meaning number of frequencies to highlight/apply to x the number of filterbanks.</span>
<span class="sd">        Each column is a filterbank so that assuming there is a matrix A of</span>
<span class="sd">        size (..., ``n_freqs``), the applied result would be</span>
<span class="sd">        ``A @ melscale_fbanks(A.size(-1), ...)``.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">norm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">norm</span> <span class="o">!=</span> <span class="s2">&quot;slaney&quot;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;norm must be one of None or &quot;slaney&quot;&#39;</span><span class="p">)</span>

    <span class="c1"># freq bins</span>
    <span class="n">all_freqs</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">sample_rate</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="n">n_freqs</span><span class="p">)</span>

    <span class="c1"># calculate mel freq bins</span>
    <span class="n">m_min</span> <span class="o">=</span> <span class="n">_hz_to_mel</span><span class="p">(</span><span class="n">f_min</span><span class="p">,</span> <span class="n">mel_scale</span><span class="o">=</span><span class="n">mel_scale</span><span class="p">)</span>
    <span class="n">m_max</span> <span class="o">=</span> <span class="n">_hz_to_mel</span><span class="p">(</span><span class="n">f_max</span><span class="p">,</span> <span class="n">mel_scale</span><span class="o">=</span><span class="n">mel_scale</span><span class="p">)</span>

    <span class="n">m_pts</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">m_min</span><span class="p">,</span> <span class="n">m_max</span><span class="p">,</span> <span class="n">n_mels</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">f_pts</span> <span class="o">=</span> <span class="n">_mel_to_hz</span><span class="p">(</span><span class="n">m_pts</span><span class="p">,</span> <span class="n">mel_scale</span><span class="o">=</span><span class="n">mel_scale</span><span class="p">)</span>

    <span class="c1"># create filterbank</span>
    <span class="n">fb</span> <span class="o">=</span> <span class="n">_create_triangular_filterbank</span><span class="p">(</span><span class="n">all_freqs</span><span class="p">,</span> <span class="n">f_pts</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">norm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">norm</span> <span class="o">==</span> <span class="s2">&quot;slaney&quot;</span><span class="p">:</span>
        <span class="c1"># Slaney-style mel is scaled to be approx constant energy per channel</span>
        <span class="n">enorm</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">f_pts</span><span class="p">[</span><span class="mi">2</span> <span class="p">:</span> <span class="n">n_mels</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">f_pts</span><span class="p">[:</span><span class="n">n_mels</span><span class="p">])</span>
        <span class="n">fb</span> <span class="o">*=</span> <span class="n">enorm</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">fb</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">values</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;At least one mel filterbank has all zero values. &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;The value for `n_mels` (</span><span class="si">{</span><span class="n">n_mels</span><span class="si">}</span><span class="s2">) may be set too high. &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;Or, the value for `n_freqs` (</span><span class="si">{</span><span class="n">n_freqs</span><span class="si">}</span><span class="s2">) may be set too low.&quot;</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">fb</span></div>


<div class="viewcode-block" id="linear_fbanks"><a class="viewcode-back" href="../../../generated/torchaudio.functional.linear_fbanks.html#torchaudio.functional.linear_fbanks">[docs]</a><span class="k">def</span> <span class="nf">linear_fbanks</span><span class="p">(</span>
    <span class="n">n_freqs</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">f_min</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">f_max</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">n_filter</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">sample_rate</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Creates a linear triangular filterbank.</span>

<span class="sd">    .. devices:: CPU</span>

<span class="sd">    .. properties:: TorchScript</span>

<span class="sd">    Note:</span>
<span class="sd">        For the sake of the numerical compatibility with librosa, not all the coefficients</span>
<span class="sd">        in the resulting filter bank has magnitude of 1.</span>

<span class="sd">        .. image:: https://download.pytorch.org/torchaudio/doc-assets/lin_fbanks.png</span>
<span class="sd">           :alt: Visualization of generated filter bank</span>

<span class="sd">    Args:</span>
<span class="sd">        n_freqs (int): Number of frequencies to highlight/apply</span>
<span class="sd">        f_min (float): Minimum frequency (Hz)</span>
<span class="sd">        f_max (float): Maximum frequency (Hz)</span>
<span class="sd">        n_filter (int): Number of (linear) triangular filter</span>
<span class="sd">        sample_rate (int): Sample rate of the audio waveform</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tensor: Triangular filter banks (fb matrix) of size (``n_freqs``, ``n_filter``)</span>
<span class="sd">        meaning number of frequencies to highlight/apply to x the number of filterbanks.</span>
<span class="sd">        Each column is a filterbank so that assuming there is a matrix A of</span>
<span class="sd">        size (..., ``n_freqs``), the applied result would be</span>
<span class="sd">        ``A * linear_fbanks(A.size(-1), ...)``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># freq bins</span>
    <span class="n">all_freqs</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">sample_rate</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="n">n_freqs</span><span class="p">)</span>

    <span class="c1"># filter mid-points</span>
    <span class="n">f_pts</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">f_min</span><span class="p">,</span> <span class="n">f_max</span><span class="p">,</span> <span class="n">n_filter</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>

    <span class="c1"># create filterbank</span>
    <span class="n">fb</span> <span class="o">=</span> <span class="n">_create_triangular_filterbank</span><span class="p">(</span><span class="n">all_freqs</span><span class="p">,</span> <span class="n">f_pts</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">fb</span></div>


<div class="viewcode-block" id="create_dct"><a class="viewcode-back" href="../../../generated/torchaudio.functional.create_dct.html#torchaudio.functional.create_dct">[docs]</a><span class="k">def</span> <span class="nf">create_dct</span><span class="p">(</span><span class="n">n_mfcc</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">n_mels</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">norm</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Create a DCT transformation matrix with shape (``n_mels``, ``n_mfcc``),</span>
<span class="sd">    normalized depending on norm.</span>

<span class="sd">    .. devices:: CPU</span>

<span class="sd">    .. properties:: TorchScript</span>

<span class="sd">    Args:</span>
<span class="sd">        n_mfcc (int): Number of mfc coefficients to retain</span>
<span class="sd">        n_mels (int): Number of mel filterbanks</span>
<span class="sd">        norm (str or None): Norm to use (either &quot;ortho&quot; or None)</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tensor: The transformation matrix, to be right-multiplied to</span>
<span class="sd">        row-wise data of size (``n_mels``, ``n_mfcc``).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">norm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">norm</span> <span class="o">!=</span> <span class="s2">&quot;ortho&quot;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;norm must be either &quot;ortho&quot; or None&#39;</span><span class="p">)</span>

    <span class="c1"># http://en.wikipedia.org/wiki/Discrete_cosine_transform#DCT-II</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">n_mels</span><span class="p">))</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">n_mfcc</span><span class="p">))</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">dct</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">n_mels</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">k</span><span class="p">)</span>  <span class="c1"># size (n_mfcc, n_mels)</span>

    <span class="k">if</span> <span class="n">norm</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dct</span> <span class="o">*=</span> <span class="mf">2.0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dct</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span>
        <span class="n">dct</span> <span class="o">*=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">n_mels</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">dct</span><span class="o">.</span><span class="n">t</span><span class="p">()</span></div>


<div class="viewcode-block" id="mu_law_encoding"><a class="viewcode-back" href="../../../generated/torchaudio.functional.mu_law_encoding.html#torchaudio.functional.mu_law_encoding">[docs]</a><span class="k">def</span> <span class="nf">mu_law_encoding</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">quantization_channels</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Encode signal based on mu-law companding.</span>

<span class="sd">    .. devices:: CPU CUDA</span>

<span class="sd">    .. properties:: TorchScript</span>

<span class="sd">    For more info see the</span>
<span class="sd">    `Wikipedia Entry &lt;https://en.wikipedia.org/wiki/%CE%9C-law_algorithm&gt;`_</span>

<span class="sd">    This algorithm expects the signal has been scaled to between -1 and 1 and</span>
<span class="sd">    returns a signal encoded with values from 0 to quantization_channels - 1.</span>

<span class="sd">    Args:</span>
<span class="sd">        x (Tensor): Input tensor</span>
<span class="sd">        quantization_channels (int): Number of channels</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tensor: Input after mu-law encoding</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="n">quantization_channels</span> <span class="o">-</span> <span class="mf">1.0</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="o">.</span><span class="n">is_floating_point</span><span class="p">():</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;The input Tensor must be of floating type. </span><span class="se">\</span>
<span class="s2">            This will be an error in the v0.12 release.&quot;</span>
        <span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">x_mu</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">log1p</span><span class="p">(</span><span class="n">mu</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">/</span> <span class="n">torch</span><span class="o">.</span><span class="n">log1p</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span>
    <span class="n">x_mu</span> <span class="o">=</span> <span class="p">((</span><span class="n">x_mu</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">mu</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x_mu</span></div>


<div class="viewcode-block" id="mu_law_decoding"><a class="viewcode-back" href="../../../generated/torchaudio.functional.mu_law_decoding.html#torchaudio.functional.mu_law_decoding">[docs]</a><span class="k">def</span> <span class="nf">mu_law_decoding</span><span class="p">(</span><span class="n">x_mu</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">quantization_channels</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Decode mu-law encoded signal.</span>

<span class="sd">    .. devices:: CPU CUDA</span>

<span class="sd">    .. properties:: TorchScript</span>

<span class="sd">    For more info see the</span>
<span class="sd">    `Wikipedia Entry &lt;https://en.wikipedia.org/wiki/%CE%9C-law_algorithm&gt;`_</span>

<span class="sd">    This expects an input with values between 0 and quantization_channels - 1</span>
<span class="sd">    and returns a signal scaled between -1 and 1.</span>

<span class="sd">    Args:</span>
<span class="sd">        x_mu (Tensor): Input tensor</span>
<span class="sd">        quantization_channels (int): Number of channels</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tensor: Input after mu-law decoding</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="n">quantization_channels</span> <span class="o">-</span> <span class="mf">1.0</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">x_mu</span><span class="o">.</span><span class="n">is_floating_point</span><span class="p">():</span>
        <span class="n">x_mu</span> <span class="o">=</span> <span class="n">x_mu</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">x_mu</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="p">((</span><span class="n">x_mu</span><span class="p">)</span> <span class="o">/</span> <span class="n">mu</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mf">1.0</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">log1p</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">/</span> <span class="n">mu</span>
    <span class="k">return</span> <span class="n">x</span></div>


<div class="viewcode-block" id="phase_vocoder"><a class="viewcode-back" href="../../../generated/torchaudio.functional.phase_vocoder.html#torchaudio.functional.phase_vocoder">[docs]</a><span class="k">def</span> <span class="nf">phase_vocoder</span><span class="p">(</span><span class="n">complex_specgrams</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">rate</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">phase_advance</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Given a STFT tensor, speed up in time without modifying pitch by a factor of ``rate``.</span>

<span class="sd">    .. devices:: CPU CUDA</span>

<span class="sd">    .. properties:: Autograd TorchScript</span>

<span class="sd">    Args:</span>
<span class="sd">        complex_specgrams (Tensor):</span>
<span class="sd">            A tensor of dimension `(..., freq, num_frame)` with complex dtype.</span>
<span class="sd">        rate (float): Speed-up factor</span>
<span class="sd">        phase_advance (Tensor): Expected phase advance in each bin. Dimension of `(freq, 1)`</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tensor:</span>
<span class="sd">            Stretched spectrogram. The resulting tensor is of the same dtype as the input</span>
<span class="sd">            spectrogram, but the number of frames is changed to ``ceil(num_frame / rate)``.</span>

<span class="sd">    Example</span>
<span class="sd">        &gt;&gt;&gt; freq, hop_length = 1025, 512</span>
<span class="sd">        &gt;&gt;&gt; # (channel, freq, time)</span>
<span class="sd">        &gt;&gt;&gt; complex_specgrams = torch.randn(2, freq, 300, dtype=torch.cfloat)</span>
<span class="sd">        &gt;&gt;&gt; rate = 1.3 # Speed up by 30%</span>
<span class="sd">        &gt;&gt;&gt; phase_advance = torch.linspace(</span>
<span class="sd">        &gt;&gt;&gt;    0, math.pi * hop_length, freq)[..., None]</span>
<span class="sd">        &gt;&gt;&gt; x = phase_vocoder(complex_specgrams, rate, phase_advance)</span>
<span class="sd">        &gt;&gt;&gt; x.shape # with 231 == ceil(300 / 1.3)</span>
<span class="sd">        torch.Size([2, 1025, 231])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">rate</span> <span class="o">==</span> <span class="mf">1.0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">complex_specgrams</span>

    <span class="c1"># pack batch</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">complex_specgrams</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
    <span class="n">complex_specgrams</span> <span class="o">=</span> <span class="n">complex_specgrams</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]))</span>

    <span class="c1"># Figures out the corresponding real dtype, i.e. complex128 -&gt; float64, complex64 -&gt; float32</span>
    <span class="c1"># Note torch.real is a view so it does not incur any memory copy.</span>
    <span class="n">real_dtype</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">complex_specgrams</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span>
    <span class="n">time_steps</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">complex_specgrams</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">rate</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">complex_specgrams</span><span class="o">.</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">real_dtype</span><span class="p">)</span>

    <span class="n">alphas</span> <span class="o">=</span> <span class="n">time_steps</span> <span class="o">%</span> <span class="mf">1.0</span>
    <span class="n">phase_0</span> <span class="o">=</span> <span class="n">complex_specgrams</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">angle</span><span class="p">()</span>

    <span class="c1"># Time Padding</span>
    <span class="n">complex_specgrams</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">functional</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">complex_specgrams</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>

    <span class="c1"># (new_bins, freq, 2)</span>
    <span class="n">complex_specgrams_0</span> <span class="o">=</span> <span class="n">complex_specgrams</span><span class="o">.</span><span class="n">index_select</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">time_steps</span><span class="o">.</span><span class="n">long</span><span class="p">())</span>
    <span class="n">complex_specgrams_1</span> <span class="o">=</span> <span class="n">complex_specgrams</span><span class="o">.</span><span class="n">index_select</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">time_steps</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">long</span><span class="p">())</span>

    <span class="n">angle_0</span> <span class="o">=</span> <span class="n">complex_specgrams_0</span><span class="o">.</span><span class="n">angle</span><span class="p">()</span>
    <span class="n">angle_1</span> <span class="o">=</span> <span class="n">complex_specgrams_1</span><span class="o">.</span><span class="n">angle</span><span class="p">()</span>

    <span class="n">norm_0</span> <span class="o">=</span> <span class="n">complex_specgrams_0</span><span class="o">.</span><span class="n">abs</span><span class="p">()</span>
    <span class="n">norm_1</span> <span class="o">=</span> <span class="n">complex_specgrams_1</span><span class="o">.</span><span class="n">abs</span><span class="p">()</span>

    <span class="n">phase</span> <span class="o">=</span> <span class="n">angle_1</span> <span class="o">-</span> <span class="n">angle_0</span> <span class="o">-</span> <span class="n">phase_advance</span>
    <span class="n">phase</span> <span class="o">=</span> <span class="n">phase</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">phase</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>

    <span class="c1"># Compute Phase Accum</span>
    <span class="n">phase</span> <span class="o">=</span> <span class="n">phase</span> <span class="o">+</span> <span class="n">phase_advance</span>
    <span class="n">phase</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">([</span><span class="n">phase_0</span><span class="p">,</span> <span class="n">phase</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">phase_acc</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">phase</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">mag</span> <span class="o">=</span> <span class="n">alphas</span> <span class="o">*</span> <span class="n">norm_1</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">alphas</span><span class="p">)</span> <span class="o">*</span> <span class="n">norm_0</span>

    <span class="n">complex_specgrams_stretch</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">polar</span><span class="p">(</span><span class="n">mag</span><span class="p">,</span> <span class="n">phase_acc</span><span class="p">)</span>

    <span class="c1"># unpack batch</span>
    <span class="n">complex_specgrams_stretch</span> <span class="o">=</span> <span class="n">complex_specgrams_stretch</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">complex_specgrams_stretch</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="k">return</span> <span class="n">complex_specgrams_stretch</span></div>


<span class="k">def</span> <span class="nf">_get_mask_param</span><span class="p">(</span><span class="n">mask_param</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">axis_length</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">p</span> <span class="o">==</span> <span class="mf">1.0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">mask_param</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">mask_param</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">axis_length</span> <span class="o">*</span> <span class="n">p</span><span class="p">))</span>


<div class="viewcode-block" id="mask_along_axis_iid"><a class="viewcode-back" href="../../../generated/torchaudio.functional.mask_along_axis_iid.html#torchaudio.functional.mask_along_axis_iid">[docs]</a><span class="k">def</span> <span class="nf">mask_along_axis_iid</span><span class="p">(</span>
    <span class="n">specgrams</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
    <span class="n">mask_param</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">mask_value</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">p</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Apply a mask along ``axis``.</span>

<span class="sd">    .. devices:: CPU CUDA</span>

<span class="sd">    .. properties:: Autograd TorchScript</span>

<span class="sd">    Mask will be applied from indices ``[v_0, v_0 + v)``,</span>
<span class="sd">    where ``v`` is sampled from ``uniform(0, max_v)`` and</span>
<span class="sd">    ``v_0`` from ``uniform(0, specgrams.size(axis) - v)``,</span>
<span class="sd">    with ``max_v = mask_param`` when ``p = 1.0`` and</span>
<span class="sd">    ``max_v = min(mask_param, floor(specgrams.size(axis) * p))`` otherwise.</span>

<span class="sd">    Args:</span>
<span class="sd">        specgrams (Tensor): Real spectrograms `(..., freq, time)`, with at least 3 dimensions.</span>
<span class="sd">        mask_param (int): Number of columns to be masked will be uniformly sampled from [0, mask_param]</span>
<span class="sd">        mask_value (float): Value to assign to the masked columns</span>
<span class="sd">        axis (int): Axis to apply masking on, which should be the one of the last two dimensions.</span>
<span class="sd">        p (float, optional): maximum proportion of columns that can be masked. (Default: 1.0)</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tensor: Masked spectrograms with the same dimensions as input specgrams Tensor`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dim</span> <span class="o">=</span> <span class="n">specgrams</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">dim</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Spectrogram must have at least three dimensions (</span><span class="si">{</span><span class="n">dim</span><span class="si">}</span><span class="s2"> given).&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">axis</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">dim</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">dim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Only Frequency and Time masking are supported (axis </span><span class="si">{</span><span class="n">dim</span><span class="o">-</span><span class="mi">2</span><span class="si">}</span><span class="s2"> and axis </span><span class="si">{</span><span class="n">dim</span><span class="o">-</span><span class="mi">1</span><span class="si">}</span><span class="s2"> supported; </span><span class="si">{</span><span class="n">axis</span><span class="si">}</span><span class="s2"> given).&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="mf">0.0</span> <span class="o">&lt;=</span> <span class="n">p</span> <span class="o">&lt;=</span> <span class="mf">1.0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The value of p must be between 0.0 and 1.0 (</span><span class="si">{</span><span class="n">p</span><span class="si">}</span><span class="s2"> given).&quot;</span><span class="p">)</span>

    <span class="n">mask_param</span> <span class="o">=</span> <span class="n">_get_mask_param</span><span class="p">(</span><span class="n">mask_param</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">specgrams</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">mask_param</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">specgrams</span>

    <span class="n">device</span> <span class="o">=</span> <span class="n">specgrams</span><span class="o">.</span><span class="n">device</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">specgrams</span><span class="o">.</span><span class="n">dtype</span>

    <span class="n">value</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">specgrams</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span> <span class="p">(</span><span class="n">dim</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)],</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span> <span class="o">*</span> <span class="n">mask_param</span>
    <span class="n">min_value</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">specgrams</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span> <span class="p">(</span><span class="n">dim</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)],</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">specgrams</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span> <span class="o">-</span> <span class="n">value</span><span class="p">)</span>

    <span class="c1"># Create broadcastable mask</span>
    <span class="n">mask_start</span> <span class="o">=</span> <span class="n">min_value</span><span class="o">.</span><span class="n">long</span><span class="p">()[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
    <span class="n">mask_end</span> <span class="o">=</span> <span class="p">(</span><span class="n">min_value</span><span class="o">.</span><span class="n">long</span><span class="p">()</span> <span class="o">+</span> <span class="n">value</span><span class="o">.</span><span class="n">long</span><span class="p">())[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">specgrams</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">axis</span><span class="p">),</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="c1"># Per batch example masking</span>
    <span class="n">specgrams</span> <span class="o">=</span> <span class="n">specgrams</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">specgrams</span> <span class="o">=</span> <span class="n">specgrams</span><span class="o">.</span><span class="n">masked_fill</span><span class="p">((</span><span class="n">mask</span> <span class="o">&gt;=</span> <span class="n">mask_start</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&lt;</span> <span class="n">mask_end</span><span class="p">),</span> <span class="n">mask_value</span><span class="p">)</span>
    <span class="n">specgrams</span> <span class="o">=</span> <span class="n">specgrams</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">specgrams</span></div>


<div class="viewcode-block" id="mask_along_axis"><a class="viewcode-back" href="../../../generated/torchaudio.functional.mask_along_axis.html#torchaudio.functional.mask_along_axis">[docs]</a><span class="k">def</span> <span class="nf">mask_along_axis</span><span class="p">(</span>
    <span class="n">specgram</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
    <span class="n">mask_param</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">mask_value</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">p</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Apply a mask along ``axis``.</span>

<span class="sd">    .. devices:: CPU CUDA</span>

<span class="sd">    .. properties:: Autograd TorchScript</span>

<span class="sd">    Mask will be applied from indices ``[v_0, v_0 + v)``,</span>
<span class="sd">    where ``v`` is sampled from ``uniform(0, max_v)`` and</span>
<span class="sd">    ``v_0`` from ``uniform(0, specgram.size(axis) - v)``, with</span>
<span class="sd">    ``max_v = mask_param`` when ``p = 1.0`` and</span>
<span class="sd">    ``max_v = min(mask_param, floor(specgram.size(axis) * p))``</span>
<span class="sd">    otherwise.</span>
<span class="sd">    All examples will have the same mask interval.</span>

<span class="sd">    Args:</span>
<span class="sd">        specgram (Tensor): Real spectrograms `(..., freq, time)`, with at least 2 dimensions.</span>
<span class="sd">        mask_param (int): Number of columns to be masked will be uniformly sampled from [0, mask_param]</span>
<span class="sd">        mask_value (float): Value to assign to the masked columns</span>
<span class="sd">        axis (int): Axis to apply masking on, which should be the one of the last two dimensions.</span>
<span class="sd">        p (float, optional): maximum proportion of columns that can be masked. (Default: 1.0)</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tensor: Masked spectrograms with the same dimensions as input specgram Tensor</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dim</span> <span class="o">=</span> <span class="n">specgram</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">dim</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Spectrogram must have at least two dimensions (time and frequency) (</span><span class="si">{</span><span class="n">dim</span><span class="si">}</span><span class="s2"> given).&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">axis</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">dim</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">dim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Only Frequency and Time masking are supported (axis </span><span class="si">{</span><span class="n">dim</span><span class="o">-</span><span class="mi">2</span><span class="si">}</span><span class="s2"> and axis </span><span class="si">{</span><span class="n">dim</span><span class="o">-</span><span class="mi">1</span><span class="si">}</span><span class="s2"> supported; </span><span class="si">{</span><span class="n">axis</span><span class="si">}</span><span class="s2"> given).&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="mf">0.0</span> <span class="o">&lt;=</span> <span class="n">p</span> <span class="o">&lt;=</span> <span class="mf">1.0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The value of p must be between 0.0 and 1.0 (</span><span class="si">{</span><span class="n">p</span><span class="si">}</span><span class="s2"> given).&quot;</span><span class="p">)</span>

    <span class="n">mask_param</span> <span class="o">=</span> <span class="n">_get_mask_param</span><span class="p">(</span><span class="n">mask_param</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">specgram</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">mask_param</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">specgram</span>

    <span class="c1"># pack batch</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">specgram</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
    <span class="n">specgram</span> <span class="o">=</span> <span class="n">specgram</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]))</span>
    <span class="c1"># After packing, specgram is a 3D tensor, and the axis corresponding to the to-be-masked dimension</span>
    <span class="c1"># is now (axis - dim + 3), e.g. a tensor of shape (10, 2, 50, 10, 2) becomes a tensor of shape (1000, 10, 2).</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">mask_param</span>
    <span class="n">min_value</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">specgram</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">axis</span> <span class="o">-</span> <span class="n">dim</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">-</span> <span class="n">value</span><span class="p">)</span>

    <span class="n">mask_start</span> <span class="o">=</span> <span class="p">(</span><span class="n">min_value</span><span class="o">.</span><span class="n">long</span><span class="p">())</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
    <span class="n">mask_end</span> <span class="o">=</span> <span class="p">(</span><span class="n">min_value</span><span class="o">.</span><span class="n">long</span><span class="p">()</span> <span class="o">+</span> <span class="n">value</span><span class="o">.</span><span class="n">long</span><span class="p">())</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">specgram</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span> <span class="o">-</span> <span class="n">dim</span> <span class="o">+</span> <span class="mi">3</span><span class="p">],</span> <span class="n">device</span><span class="o">=</span><span class="n">specgram</span><span class="o">.</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">specgram</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&gt;=</span> <span class="n">mask_start</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&lt;</span> <span class="n">mask_end</span><span class="p">)</span>
    <span class="c1"># unsqueeze the mask if the axis is frequency</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="n">dim</span> <span class="o">-</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">mask_end</span> <span class="o">-</span> <span class="n">mask_start</span> <span class="o">&gt;=</span> <span class="n">mask_param</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Number of columns to be masked should be less than mask_param&quot;</span><span class="p">)</span>

    <span class="n">specgram</span> <span class="o">=</span> <span class="n">specgram</span><span class="o">.</span><span class="n">masked_fill</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">mask_value</span><span class="p">)</span>

    <span class="c1"># unpack batch</span>
    <span class="n">specgram</span> <span class="o">=</span> <span class="n">specgram</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">specgram</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:])</span>

    <span class="k">return</span> <span class="n">specgram</span></div>


<div class="viewcode-block" id="compute_deltas"><a class="viewcode-back" href="../../../generated/torchaudio.functional.compute_deltas.html#torchaudio.functional.compute_deltas">[docs]</a><span class="k">def</span> <span class="nf">compute_deltas</span><span class="p">(</span><span class="n">specgram</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">win_length</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;replicate&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Compute delta coefficients of a tensor, usually a spectrogram:</span>

<span class="sd">    .. devices:: CPU CUDA</span>

<span class="sd">    .. properties:: TorchScript</span>

<span class="sd">    .. math::</span>
<span class="sd">       d_t = \frac{\sum_{n=1}^{\text{N}} n (c_{t+n} - c_{t-n})}{2 \sum_{n=1}^{\text{N}} n^2}</span>

<span class="sd">    where :math:`d_t` is the deltas at time :math:`t`,</span>
<span class="sd">    :math:`c_t` is the spectrogram coeffcients at time :math:`t`,</span>
<span class="sd">    :math:`N` is ``(win_length-1)//2``.</span>

<span class="sd">    Args:</span>
<span class="sd">        specgram (Tensor): Tensor of audio of dimension `(..., freq, time)`</span>
<span class="sd">        win_length (int, optional): The window length used for computing delta (Default: ``5``)</span>
<span class="sd">        mode (str, optional): Mode parameter passed to padding (Default: ``&quot;replicate&quot;``)</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tensor: Tensor of deltas of dimension `(..., freq, time)`</span>

<span class="sd">    Example</span>
<span class="sd">        &gt;&gt;&gt; specgram = torch.randn(1, 40, 1000)</span>
<span class="sd">        &gt;&gt;&gt; delta = compute_deltas(specgram)</span>
<span class="sd">        &gt;&gt;&gt; delta2 = compute_deltas(delta)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">device</span> <span class="o">=</span> <span class="n">specgram</span><span class="o">.</span><span class="n">device</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">specgram</span><span class="o">.</span><span class="n">dtype</span>

    <span class="c1"># pack batch</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">specgram</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
    <span class="n">specgram</span> <span class="o">=</span> <span class="n">specgram</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">win_length</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Window length should be greater than or equal to 3. Found win_length </span><span class="si">{</span><span class="n">win_length</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="n">win_length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>

    <span class="c1"># twice sum of integer squared</span>
    <span class="n">denom</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span>

    <span class="n">specgram</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">functional</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">specgram</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>

    <span class="n">kernel</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">specgram</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">output</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">functional</span><span class="o">.</span><span class="n">conv1d</span><span class="p">(</span><span class="n">specgram</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">groups</span><span class="o">=</span><span class="n">specgram</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">denom</span>

    <span class="c1"># unpack batch</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">output</span></div>


<span class="k">def</span> <span class="nf">_compute_nccf</span><span class="p">(</span><span class="n">waveform</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">sample_rate</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">frame_time</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">freq_low</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute Normalized Cross-Correlation Function (NCCF).</span>

<span class="sd">    .. math::</span>
<span class="sd">        \phi_i(m) = \frac{\sum_{n=b_i}^{b_i + N-1} w(n) w(m+n)}{\sqrt{E(b_i) E(m+b_i)}},</span>

<span class="sd">    where</span>
<span class="sd">    :math:`\phi_i(m)` is the NCCF at frame :math:`i` with lag :math:`m`,</span>
<span class="sd">    :math:`w` is the waveform,</span>
<span class="sd">    :math:`N` is the length of a frame,</span>
<span class="sd">    :math:`b_i` is the beginning of frame :math:`i`,</span>
<span class="sd">    :math:`E(j)` is the energy :math:`\sum_{n=j}^{j+N-1} w^2(n)`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">EPSILON</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">9</span><span class="p">)</span>

    <span class="c1"># Number of lags to check</span>
    <span class="n">lags</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">sample_rate</span> <span class="o">/</span> <span class="n">freq_low</span><span class="p">))</span>

    <span class="n">frame_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">sample_rate</span> <span class="o">*</span> <span class="n">frame_time</span><span class="p">))</span>

    <span class="n">waveform_length</span> <span class="o">=</span> <span class="n">waveform</span><span class="o">.</span><span class="n">size</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">num_of_frames</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">waveform_length</span> <span class="o">/</span> <span class="n">frame_size</span><span class="p">))</span>

    <span class="n">p</span> <span class="o">=</span> <span class="n">lags</span> <span class="o">+</span> <span class="n">num_of_frames</span> <span class="o">*</span> <span class="n">frame_size</span> <span class="o">-</span> <span class="n">waveform_length</span>
    <span class="n">waveform</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">functional</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">waveform</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>

    <span class="c1"># Compute lags</span>
    <span class="n">output_lag</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">lag</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">lags</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">s1</span> <span class="o">=</span> <span class="n">waveform</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="n">lag</span><span class="p">]</span><span class="o">.</span><span class="n">unfold</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">frame_size</span><span class="p">,</span> <span class="n">frame_size</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="n">num_of_frames</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">s2</span> <span class="o">=</span> <span class="n">waveform</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">lag</span><span class="p">:]</span><span class="o">.</span><span class="n">unfold</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">frame_size</span><span class="p">,</span> <span class="n">frame_size</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="n">num_of_frames</span><span class="p">,</span> <span class="p">:]</span>

        <span class="n">output_frames</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">s1</span> <span class="o">*</span> <span class="n">s2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="o">/</span> <span class="p">(</span><span class="n">EPSILON</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">vector_norm</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
            <span class="o">/</span> <span class="p">(</span><span class="n">EPSILON</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">vector_norm</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="n">output_lag</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">output_frames</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>

    <span class="n">nccf</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span><span class="n">output_lag</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">nccf</span>


<span class="k">def</span> <span class="nf">_combine_max</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">],</span> <span class="n">b</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">],</span> <span class="n">thresh</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.99</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Take value from first if bigger than a multiplicative factor of the second, elementwise.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">thresh</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">values</span> <span class="o">=</span> <span class="n">mask</span> <span class="o">*</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="o">~</span><span class="n">mask</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">mask</span> <span class="o">*</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="o">~</span><span class="n">mask</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">values</span><span class="p">,</span> <span class="n">indices</span>


<span class="k">def</span> <span class="nf">_find_max_per_frame</span><span class="p">(</span><span class="n">nccf</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">sample_rate</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">freq_high</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    For each frame, take the highest value of NCCF,</span>
<span class="sd">    apply centered median smoothing, and convert to frequency.</span>

<span class="sd">    Note: If the max among all the lags is very close</span>
<span class="sd">    to the first half of lags, then the latter is taken.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">lag_min</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">sample_rate</span> <span class="o">/</span> <span class="n">freq_high</span><span class="p">))</span>

    <span class="c1"># Find near enough max that is smallest</span>

    <span class="n">best</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">nccf</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">lag_min</span><span class="p">:],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">half_size</span> <span class="o">=</span> <span class="n">nccf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">half</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">nccf</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">lag_min</span><span class="p">:</span><span class="n">half_size</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">best</span> <span class="o">=</span> <span class="n">_combine_max</span><span class="p">(</span><span class="n">half</span><span class="p">,</span> <span class="n">best</span><span class="p">)</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">best</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Add back minimal lag</span>
    <span class="n">indices</span> <span class="o">+=</span> <span class="n">lag_min</span>
    <span class="c1"># Add 1 empirical calibration offset</span>
    <span class="n">indices</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">indices</span>


<span class="k">def</span> <span class="nf">_median_smoothing</span><span class="p">(</span><span class="n">indices</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">win_length</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply median smoothing to the 1D tensor over the given window.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Centered windowed</span>
    <span class="n">pad_length</span> <span class="o">=</span> <span class="p">(</span><span class="n">win_length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>

    <span class="c1"># &quot;replicate&quot; padding in any dimension</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">functional</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="p">(</span><span class="n">pad_length</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;constant&quot;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>

    <span class="n">indices</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="n">pad_length</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span><span class="n">pad_length</span> <span class="o">*</span> <span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">pad_length</span><span class="p">]</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)],</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">roll</span> <span class="o">=</span> <span class="n">indices</span><span class="o">.</span><span class="n">unfold</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">win_length</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">values</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">roll</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">values</span>


<div class="viewcode-block" id="detect_pitch_frequency"><a class="viewcode-back" href="../../../generated/torchaudio.functional.detect_pitch_frequency.html#torchaudio.functional.detect_pitch_frequency">[docs]</a><span class="k">def</span> <span class="nf">detect_pitch_frequency</span><span class="p">(</span>
    <span class="n">waveform</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
    <span class="n">sample_rate</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">frame_time</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">),</span>
    <span class="n">win_length</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span>
    <span class="n">freq_low</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">85</span><span class="p">,</span>
    <span class="n">freq_high</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3400</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Detect pitch frequency.</span>

<span class="sd">    .. devices:: CPU CUDA</span>

<span class="sd">    .. properties:: TorchScript</span>

<span class="sd">    It is implemented using normalized cross-correlation function and median smoothing.</span>

<span class="sd">    Args:</span>
<span class="sd">        waveform (Tensor): Tensor of audio of dimension `(..., freq, time)`</span>
<span class="sd">        sample_rate (int): The sample rate of the waveform (Hz)</span>
<span class="sd">        frame_time (float, optional): Duration of a frame (Default: ``10 ** (-2)``).</span>
<span class="sd">        win_length (int, optional): The window length for median smoothing (in number of frames) (Default: ``30``).</span>
<span class="sd">        freq_low (int, optional): Lowest frequency that can be detected (Hz) (Default: ``85``).</span>
<span class="sd">        freq_high (int, optional): Highest frequency that can be detected (Hz) (Default: ``3400``).</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tensor: Tensor of freq of dimension `(..., frame)`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># pack batch</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">waveform</span><span class="o">.</span><span class="n">size</span><span class="p">())</span>
    <span class="n">waveform</span> <span class="o">=</span> <span class="n">waveform</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:])</span>

    <span class="n">nccf</span> <span class="o">=</span> <span class="n">_compute_nccf</span><span class="p">(</span><span class="n">waveform</span><span class="p">,</span> <span class="n">sample_rate</span><span class="p">,</span> <span class="n">frame_time</span><span class="p">,</span> <span class="n">freq_low</span><span class="p">)</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">_find_max_per_frame</span><span class="p">(</span><span class="n">nccf</span><span class="p">,</span> <span class="n">sample_rate</span><span class="p">,</span> <span class="n">freq_high</span><span class="p">)</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">_median_smoothing</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">win_length</span><span class="p">)</span>

    <span class="c1"># Convert indices to frequency</span>
    <span class="n">EPSILON</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">9</span><span class="p">)</span>
    <span class="n">freq</span> <span class="o">=</span> <span class="n">sample_rate</span> <span class="o">/</span> <span class="p">(</span><span class="n">EPSILON</span> <span class="o">+</span> <span class="n">indices</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">))</span>

    <span class="c1"># unpack batch</span>
    <span class="n">freq</span> <span class="o">=</span> <span class="n">freq</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">freq</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:]))</span>

    <span class="k">return</span> <span class="n">freq</span></div>


<div class="viewcode-block" id="sliding_window_cmn"><a class="viewcode-back" href="../../../generated/torchaudio.functional.sliding_window_cmn.html#torchaudio.functional.sliding_window_cmn">[docs]</a><span class="k">def</span> <span class="nf">sliding_window_cmn</span><span class="p">(</span>
    <span class="n">specgram</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
    <span class="n">cmn_window</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">600</span><span class="p">,</span>
    <span class="n">min_cmn_window</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
    <span class="n">center</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">norm_vars</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply sliding-window cepstral mean (and optionally variance) normalization per utterance.</span>

<span class="sd">    .. devices:: CPU CUDA</span>

<span class="sd">    .. properties:: TorchScript</span>

<span class="sd">    Args:</span>
<span class="sd">        specgram (Tensor): Tensor of spectrogram of dimension `(..., time, freq)`</span>
<span class="sd">        cmn_window (int, optional): Window in frames for running average CMN computation (int, default = 600)</span>
<span class="sd">        min_cmn_window (int, optional):  Minimum CMN window used at start of decoding (adds latency only at start).</span>
<span class="sd">            Only applicable if center == false, ignored if center==true (int, default = 100)</span>
<span class="sd">        center (bool, optional): If true, use a window centered on the current frame</span>
<span class="sd">            (to the extent possible, modulo end effects). If false, window is to the left. (bool, default = false)</span>
<span class="sd">        norm_vars (bool, optional): If true, normalize variance to one. (bool, default = false)</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tensor: Tensor matching input shape `(..., freq, time)`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">input_shape</span> <span class="o">=</span> <span class="n">specgram</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">num_frames</span><span class="p">,</span> <span class="n">num_feats</span> <span class="o">=</span> <span class="n">input_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span>
    <span class="n">specgram</span> <span class="o">=</span> <span class="n">specgram</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_frames</span><span class="p">,</span> <span class="n">num_feats</span><span class="p">)</span>
    <span class="n">num_channels</span> <span class="o">=</span> <span class="n">specgram</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">dtype</span> <span class="o">=</span> <span class="n">specgram</span><span class="o">.</span><span class="n">dtype</span>
    <span class="n">device</span> <span class="o">=</span> <span class="n">specgram</span><span class="o">.</span><span class="n">device</span>
    <span class="n">last_window_start</span> <span class="o">=</span> <span class="n">last_window_end</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">cur_sum</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_channels</span><span class="p">,</span> <span class="n">num_feats</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
    <span class="n">cur_sumsq</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_channels</span><span class="p">,</span> <span class="n">num_feats</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
    <span class="n">cmn_specgram</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_channels</span><span class="p">,</span> <span class="n">num_frames</span><span class="p">,</span> <span class="n">num_feats</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_frames</span><span class="p">):</span>
        <span class="n">window_start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">window_end</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">center</span><span class="p">:</span>
            <span class="n">window_start</span> <span class="o">=</span> <span class="n">t</span> <span class="o">-</span> <span class="n">cmn_window</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="n">window_end</span> <span class="o">=</span> <span class="n">window_start</span> <span class="o">+</span> <span class="n">cmn_window</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">window_start</span> <span class="o">=</span> <span class="n">t</span> <span class="o">-</span> <span class="n">cmn_window</span>
            <span class="n">window_end</span> <span class="o">=</span> <span class="n">t</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">window_start</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">window_end</span> <span class="o">-=</span> <span class="n">window_start</span>
            <span class="n">window_start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">center</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">window_end</span> <span class="o">&gt;</span> <span class="n">t</span><span class="p">:</span>
                <span class="n">window_end</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">t</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">min_cmn_window</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">window_end</span> <span class="o">&gt;</span> <span class="n">num_frames</span><span class="p">:</span>
            <span class="n">window_start</span> <span class="o">-=</span> <span class="n">window_end</span> <span class="o">-</span> <span class="n">num_frames</span>
            <span class="n">window_end</span> <span class="o">=</span> <span class="n">num_frames</span>
            <span class="k">if</span> <span class="n">window_start</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">window_start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">last_window_start</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">input_part</span> <span class="o">=</span> <span class="n">specgram</span><span class="p">[:,</span> <span class="n">window_start</span> <span class="p">:</span> <span class="n">window_end</span> <span class="o">-</span> <span class="n">window_start</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">cur_sum</span> <span class="o">+=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">input_part</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">norm_vars</span><span class="p">:</span>
                <span class="n">cur_sumsq</span> <span class="o">+=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">input_part</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">window_start</span> <span class="o">&gt;</span> <span class="n">last_window_start</span><span class="p">:</span>
                <span class="n">frame_to_remove</span> <span class="o">=</span> <span class="n">specgram</span><span class="p">[:,</span> <span class="n">last_window_start</span><span class="p">,</span> <span class="p">:]</span>
                <span class="n">cur_sum</span> <span class="o">-=</span> <span class="n">frame_to_remove</span>
                <span class="k">if</span> <span class="n">norm_vars</span><span class="p">:</span>
                    <span class="n">cur_sumsq</span> <span class="o">-=</span> <span class="n">frame_to_remove</span><span class="o">**</span><span class="mi">2</span>
            <span class="k">if</span> <span class="n">window_end</span> <span class="o">&gt;</span> <span class="n">last_window_end</span><span class="p">:</span>
                <span class="n">frame_to_add</span> <span class="o">=</span> <span class="n">specgram</span><span class="p">[:,</span> <span class="n">last_window_end</span><span class="p">,</span> <span class="p">:]</span>
                <span class="n">cur_sum</span> <span class="o">+=</span> <span class="n">frame_to_add</span>
                <span class="k">if</span> <span class="n">norm_vars</span><span class="p">:</span>
                    <span class="n">cur_sumsq</span> <span class="o">+=</span> <span class="n">frame_to_add</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">window_frames</span> <span class="o">=</span> <span class="n">window_end</span> <span class="o">-</span> <span class="n">window_start</span>
        <span class="n">last_window_start</span> <span class="o">=</span> <span class="n">window_start</span>
        <span class="n">last_window_end</span> <span class="o">=</span> <span class="n">window_end</span>
        <span class="n">cmn_specgram</span><span class="p">[:,</span> <span class="n">t</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">specgram</span><span class="p">[:,</span> <span class="n">t</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">cur_sum</span> <span class="o">/</span> <span class="n">window_frames</span>
        <span class="k">if</span> <span class="n">norm_vars</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">window_frames</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">cmn_specgram</span><span class="p">[:,</span> <span class="n">t</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_channels</span><span class="p">,</span> <span class="n">num_feats</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">variance</span> <span class="o">=</span> <span class="n">cur_sumsq</span>
                <span class="n">variance</span> <span class="o">=</span> <span class="n">variance</span> <span class="o">/</span> <span class="n">window_frames</span>
                <span class="n">variance</span> <span class="o">-=</span> <span class="p">(</span><span class="n">cur_sum</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">window_frames</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">variance</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="n">variance</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">)</span>
                <span class="n">cmn_specgram</span><span class="p">[:,</span> <span class="n">t</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*=</span> <span class="n">variance</span>

    <span class="n">cmn_specgram</span> <span class="o">=</span> <span class="n">cmn_specgram</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">input_shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">num_frames</span><span class="p">,</span> <span class="n">num_feats</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">cmn_specgram</span> <span class="o">=</span> <span class="n">cmn_specgram</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cmn_specgram</span></div>


<div class="viewcode-block" id="spectral_centroid"><a class="viewcode-back" href="../../../generated/torchaudio.functional.spectral_centroid.html#torchaudio.functional.spectral_centroid">[docs]</a><span class="k">def</span> <span class="nf">spectral_centroid</span><span class="p">(</span>
    <span class="n">waveform</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
    <span class="n">sample_rate</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">pad</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">window</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
    <span class="n">n_fft</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">hop_length</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">win_length</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Compute the spectral centroid for each channel along the time axis.</span>

<span class="sd">    .. devices:: CPU CUDA</span>

<span class="sd">    .. properties:: Autograd TorchScript</span>

<span class="sd">    The spectral centroid is defined as the weighted average of the</span>
<span class="sd">    frequency values, weighted by their magnitude.</span>

<span class="sd">    Args:</span>
<span class="sd">        waveform (Tensor): Tensor of audio of dimension `(..., time)`</span>
<span class="sd">        sample_rate (int): Sample rate of the audio waveform</span>
<span class="sd">        pad (int): Two sided padding of signal</span>
<span class="sd">        window (Tensor): Window tensor that is applied/multiplied to each frame/window</span>
<span class="sd">        n_fft (int): Size of FFT</span>
<span class="sd">        hop_length (int): Length of hop between STFT windows</span>
<span class="sd">        win_length (int): Window size</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tensor: Dimension `(..., time)`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">specgram</span> <span class="o">=</span> <span class="n">spectrogram</span><span class="p">(</span>
        <span class="n">waveform</span><span class="p">,</span>
        <span class="n">pad</span><span class="o">=</span><span class="n">pad</span><span class="p">,</span>
        <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
        <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span>
        <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span>
        <span class="n">win_length</span><span class="o">=</span><span class="n">win_length</span><span class="p">,</span>
        <span class="n">power</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
        <span class="n">normalized</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">freqs</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">sample_rate</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="n">steps</span><span class="o">=</span><span class="mi">1</span> <span class="o">+</span> <span class="n">n_fft</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">specgram</span><span class="o">.</span><span class="n">device</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">freq_dim</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">freqs</span> <span class="o">*</span> <span class="n">specgram</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">freq_dim</span><span class="p">)</span> <span class="o">/</span> <span class="n">specgram</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">freq_dim</span><span class="p">)</span></div>


<div class="viewcode-block" id="apply_codec"><a class="viewcode-back" href="../../../generated/torchaudio.functional.apply_codec.html#torchaudio.functional.apply_codec">[docs]</a><span class="nd">@deprecated</span><span class="p">(</span><span class="s2">&quot;Please migrate to :py:class:`torchaudio.io.AudioEffector`.&quot;</span><span class="p">,</span> <span class="n">remove</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">apply_codec</span><span class="p">(</span>
    <span class="n">waveform</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
    <span class="n">sample_rate</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="nb">format</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">channels_first</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">compression</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">encoding</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">bits_per_sample</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply codecs as a form of augmentation.</span>

<span class="sd">    .. devices:: CPU</span>

<span class="sd">    Args:</span>
<span class="sd">        waveform (Tensor): Audio data. Must be 2 dimensional. See also ```channels_first```.</span>
<span class="sd">        sample_rate (int): Sample rate of the audio waveform.</span>
<span class="sd">        format (str): File format.</span>
<span class="sd">        channels_first (bool, optional):</span>
<span class="sd">            When True, both the input and output Tensor have dimension `(channel, time)`.</span>
<span class="sd">            Otherwise, they have dimension `(time, channel)`.</span>
<span class="sd">        compression (float or None, optional): Used for formats other than WAV.</span>
<span class="sd">            For more details see :py:func:`torchaudio.backend.sox_io_backend.save`.</span>
<span class="sd">        encoding (str or None, optional): Changes the encoding for the supported formats.</span>
<span class="sd">            For more details see :py:func:`torchaudio.backend.sox_io_backend.save`.</span>
<span class="sd">        bits_per_sample (int or None, optional): Changes the bit depth for the supported formats.</span>
<span class="sd">            For more details see :py:func:`torchaudio.backend.sox_io_backend.save`.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tensor: Resulting Tensor.</span>
<span class="sd">        If ``channels_first=True``, it has `(channel, time)` else `(time, channel)`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">torchaudio.backend</span> <span class="kn">import</span> <span class="n">_sox_io_backend</span>

    <span class="k">with</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">NamedTemporaryFile</span><span class="p">()</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">torchaudio</span><span class="o">.</span><span class="n">backend</span><span class="o">.</span><span class="n">_sox_io_backend</span><span class="o">.</span><span class="n">save</span><span class="p">(</span>
            <span class="n">f</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">waveform</span><span class="p">,</span> <span class="n">sample_rate</span><span class="p">,</span> <span class="n">channels_first</span><span class="p">,</span> <span class="n">compression</span><span class="p">,</span> <span class="nb">format</span><span class="p">,</span> <span class="n">encoding</span><span class="p">,</span> <span class="n">bits_per_sample</span>
        <span class="p">)</span>
        <span class="n">augmented</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">_sox_io_backend</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">channels_first</span><span class="o">=</span><span class="n">channels_first</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="nb">format</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sr</span> <span class="o">!=</span> <span class="n">sample_rate</span><span class="p">:</span>
        <span class="n">augmented</span> <span class="o">=</span> <span class="n">resample</span><span class="p">(</span><span class="n">augmented</span><span class="p">,</span> <span class="n">sr</span><span class="p">,</span> <span class="n">sample_rate</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">augmented</span></div>


<span class="n">_CPU</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s2">&quot;cpu&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_get_sinc_resample_kernel</span><span class="p">(</span>
    <span class="n">orig_freq</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">new_freq</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">gcd</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">lowpass_filter_width</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
    <span class="n">rolloff</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.99</span><span class="p">,</span>
    <span class="n">resampling_method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;sinc_interp_hann&quot;</span><span class="p">,</span>
    <span class="n">beta</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="n">_CPU</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">dtype</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">orig_freq</span><span class="p">)</span> <span class="o">==</span> <span class="n">orig_freq</span> <span class="ow">and</span> <span class="nb">int</span><span class="p">(</span><span class="n">new_freq</span><span class="p">)</span> <span class="o">==</span> <span class="n">new_freq</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
            <span class="s2">&quot;Frequencies must be of integer type to ensure quality resampling computation. &quot;</span>
            <span class="s2">&quot;To work around this, manually convert both frequencies to integer values &quot;</span>
            <span class="s2">&quot;that maintain their resampling rate ratio before passing them into the function. &quot;</span>
            <span class="s2">&quot;Example: To downsample a 44100 hz waveform by a factor of 8, use &quot;</span>
            <span class="s2">&quot;`orig_freq=8` and `new_freq=1` instead of `orig_freq=44100` and `new_freq=5512.5`. &quot;</span>
            <span class="s2">&quot;For more information, please refer to https://github.com/pytorch/audio/issues/1487.&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">resampling_method</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;sinc_interpolation&quot;</span><span class="p">,</span> <span class="s2">&quot;kaiser_window&quot;</span><span class="p">]:</span>
        <span class="n">method_map</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;sinc_interpolation&quot;</span><span class="p">:</span> <span class="s2">&quot;sinc_interp_hann&quot;</span><span class="p">,</span>
            <span class="s2">&quot;kaiser_window&quot;</span><span class="p">:</span> <span class="s2">&quot;sinc_interp_kaiser&quot;</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="sa">f</span><span class="s1">&#39;&quot;</span><span class="si">{</span><span class="n">resampling_method</span><span class="si">}</span><span class="s1">&quot; resampling method name is being deprecated and replaced by &#39;</span>
            <span class="sa">f</span><span class="s1">&#39;&quot;</span><span class="si">{</span><span class="n">method_map</span><span class="p">[</span><span class="n">resampling_method</span><span class="p">]</span><span class="si">}</span><span class="s1">&quot; in the next release. &#39;</span>
            <span class="s2">&quot;The default behavior remains unchanged.&quot;</span><span class="p">,</span>
            <span class="n">stacklevel</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="n">resampling_method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;sinc_interp_hann&quot;</span><span class="p">,</span> <span class="s2">&quot;sinc_interp_kaiser&quot;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid resampling method: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">resampling_method</span><span class="p">))</span>

    <span class="n">orig_freq</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">orig_freq</span><span class="p">)</span> <span class="o">//</span> <span class="n">gcd</span>
    <span class="n">new_freq</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">new_freq</span><span class="p">)</span> <span class="o">//</span> <span class="n">gcd</span>

    <span class="k">if</span> <span class="n">lowpass_filter_width</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Low pass filter width should be positive.&quot;</span><span class="p">)</span>
    <span class="n">base_freq</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">orig_freq</span><span class="p">,</span> <span class="n">new_freq</span><span class="p">)</span>
    <span class="c1"># This will perform antialiasing filtering by removing the highest frequencies.</span>
    <span class="c1"># At first I thought I only needed this when downsampling, but when upsampling</span>
    <span class="c1"># you will get edge artifacts without this, as the edge is equivalent to zero padding,</span>
    <span class="c1"># which will add high freq artifacts.</span>
    <span class="n">base_freq</span> <span class="o">*=</span> <span class="n">rolloff</span>

    <span class="c1"># The key idea of the algorithm is that x(t) can be exactly reconstructed from x[i] (tensor)</span>
    <span class="c1"># using the sinc interpolation formula:</span>
    <span class="c1">#   x(t) = sum_i x[i] sinc(pi * orig_freq * (i / orig_freq - t))</span>
    <span class="c1"># We can then sample the function x(t) with a different sample rate:</span>
    <span class="c1">#    y[j] = x(j / new_freq)</span>
    <span class="c1"># or,</span>
    <span class="c1">#    y[j] = sum_i x[i] sinc(pi * orig_freq * (i / orig_freq - j / new_freq))</span>

    <span class="c1"># We see here that y[j] is the convolution of x[i] with a specific filter, for which</span>
    <span class="c1"># we take an FIR approximation, stopping when we see at least `lowpass_filter_width` zeros crossing.</span>
    <span class="c1"># But y[j+1] is going to have a different set of weights and so on, until y[j + new_freq].</span>
    <span class="c1"># Indeed:</span>
    <span class="c1"># y[j + new_freq] = sum_i x[i] sinc(pi * orig_freq * ((i / orig_freq - (j + new_freq) / new_freq))</span>
    <span class="c1">#                 = sum_i x[i] sinc(pi * orig_freq * ((i - orig_freq) / orig_freq - j / new_freq))</span>
    <span class="c1">#                 = sum_i x[i + orig_freq] sinc(pi * orig_freq * (i / orig_freq - j / new_freq))</span>
    <span class="c1"># so y[j+new_freq] uses the same filter as y[j], but on a shifted version of x by `orig_freq`.</span>
    <span class="c1"># This will explain the F.conv1d after, with a stride of orig_freq.</span>
    <span class="n">width</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">lowpass_filter_width</span> <span class="o">*</span> <span class="n">orig_freq</span> <span class="o">/</span> <span class="n">base_freq</span><span class="p">)</span>
    <span class="c1"># If orig_freq is still big after GCD reduction, most filters will be very unbalanced, i.e.,</span>
    <span class="c1"># they will have a lot of almost zero values to the left or to the right...</span>
    <span class="c1"># There is probably a way to evaluate those filters more efficiently, but this is kept for</span>
    <span class="c1"># future work.</span>
    <span class="n">idx_dtype</span> <span class="o">=</span> <span class="n">dtype</span> <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">torch</span><span class="o">.</span><span class="n">float64</span>

    <span class="n">idx</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">width</span><span class="p">,</span> <span class="n">width</span> <span class="o">+</span> <span class="n">orig_freq</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">idx_dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">/</span> <span class="n">orig_freq</span>

    <span class="n">t</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">new_freq</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">/</span> <span class="n">new_freq</span> <span class="o">+</span> <span class="n">idx</span>
    <span class="n">t</span> <span class="o">*=</span> <span class="n">base_freq</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">clamp_</span><span class="p">(</span><span class="o">-</span><span class="n">lowpass_filter_width</span><span class="p">,</span> <span class="n">lowpass_filter_width</span><span class="p">)</span>

    <span class="c1"># we do not use built in torch windows here as we need to evaluate the window</span>
    <span class="c1"># at specific positions, not over a regular grid.</span>
    <span class="k">if</span> <span class="n">resampling_method</span> <span class="o">==</span> <span class="s2">&quot;sinc_interp_hann&quot;</span><span class="p">:</span>
        <span class="n">window</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">t</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">lowpass_filter_width</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># sinc_interp_kaiser</span>
        <span class="k">if</span> <span class="n">beta</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">beta</span> <span class="o">=</span> <span class="mf">14.769656459379492</span>
        <span class="n">beta_tensor</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">beta</span><span class="p">))</span>
        <span class="n">window</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">i0</span><span class="p">(</span><span class="n">beta_tensor</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">t</span> <span class="o">/</span> <span class="n">lowpass_filter_width</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="n">torch</span><span class="o">.</span><span class="n">i0</span><span class="p">(</span><span class="n">beta_tensor</span><span class="p">)</span>

    <span class="n">t</span> <span class="o">*=</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span>

    <span class="n">scale</span> <span class="o">=</span> <span class="n">base_freq</span> <span class="o">/</span> <span class="n">orig_freq</span>
    <span class="n">kernels</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">t</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">t</span><span class="o">.</span><span class="n">sin</span><span class="p">()</span> <span class="o">/</span> <span class="n">t</span><span class="p">)</span>
    <span class="n">kernels</span> <span class="o">*=</span> <span class="n">window</span> <span class="o">*</span> <span class="n">scale</span>

    <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">kernels</span> <span class="o">=</span> <span class="n">kernels</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">kernels</span><span class="p">,</span> <span class="n">width</span>


<span class="k">def</span> <span class="nf">_apply_sinc_resample_kernel</span><span class="p">(</span>
    <span class="n">waveform</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
    <span class="n">orig_freq</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">new_freq</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">gcd</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">kernel</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
    <span class="n">width</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
<span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">waveform</span><span class="o">.</span><span class="n">is_floating_point</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Expected floating point type for waveform tensor, but received </span><span class="si">{</span><span class="n">waveform</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

    <span class="n">orig_freq</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">orig_freq</span><span class="p">)</span> <span class="o">//</span> <span class="n">gcd</span>
    <span class="n">new_freq</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">new_freq</span><span class="p">)</span> <span class="o">//</span> <span class="n">gcd</span>

    <span class="c1"># pack batch</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">waveform</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
    <span class="n">waveform</span> <span class="o">=</span> <span class="n">waveform</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="n">num_wavs</span><span class="p">,</span> <span class="n">length</span> <span class="o">=</span> <span class="n">waveform</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">waveform</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">functional</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">waveform</span><span class="p">,</span> <span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">width</span> <span class="o">+</span> <span class="n">orig_freq</span><span class="p">))</span>
    <span class="n">resampled</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">functional</span><span class="o">.</span><span class="n">conv1d</span><span class="p">(</span><span class="n">waveform</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="n">orig_freq</span><span class="p">)</span>
    <span class="n">resampled</span> <span class="o">=</span> <span class="n">resampled</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">num_wavs</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">target_length</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">new_freq</span> <span class="o">*</span> <span class="n">length</span> <span class="o">/</span> <span class="n">orig_freq</span><span class="p">))</span><span class="o">.</span><span class="n">long</span><span class="p">()</span>
    <span class="n">resampled</span> <span class="o">=</span> <span class="n">resampled</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="n">target_length</span><span class="p">]</span>

    <span class="c1"># unpack batch</span>
    <span class="n">resampled</span> <span class="o">=</span> <span class="n">resampled</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">resampled</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:])</span>
    <span class="k">return</span> <span class="n">resampled</span>


<div class="viewcode-block" id="resample"><a class="viewcode-back" href="../../../generated/torchaudio.functional.resample.html#torchaudio.functional.resample">[docs]</a><span class="k">def</span> <span class="nf">resample</span><span class="p">(</span>
    <span class="n">waveform</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
    <span class="n">orig_freq</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">new_freq</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">lowpass_filter_width</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
    <span class="n">rolloff</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.99</span><span class="p">,</span>
    <span class="n">resampling_method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;sinc_interp_hann&quot;</span><span class="p">,</span>
    <span class="n">beta</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Resamples the waveform at the new frequency using bandlimited interpolation. :cite:`RESAMPLE`.</span>

<span class="sd">    .. devices:: CPU CUDA</span>

<span class="sd">    .. properties:: Autograd TorchScript</span>

<span class="sd">    Note:</span>
<span class="sd">        ``transforms.Resample`` precomputes and reuses the resampling kernel, so using it will result in</span>
<span class="sd">        more efficient computation if resampling multiple waveforms with the same resampling parameters.</span>

<span class="sd">    Args:</span>
<span class="sd">        waveform (Tensor): The input signal of dimension `(..., time)`</span>
<span class="sd">        orig_freq (int): The original frequency of the signal</span>
<span class="sd">        new_freq (int): The desired frequency</span>
<span class="sd">        lowpass_filter_width (int, optional): Controls the sharpness of the filter, more == sharper</span>
<span class="sd">            but less efficient. (Default: ``6``)</span>
<span class="sd">        rolloff (float, optional): The roll-off frequency of the filter, as a fraction of the Nyquist.</span>
<span class="sd">            Lower values reduce anti-aliasing, but also reduce some of the highest frequencies. (Default: ``0.99``)</span>
<span class="sd">        resampling_method (str, optional): The resampling method to use.</span>
<span class="sd">            Options: [``&quot;sinc_interp_hann&quot;``, ``&quot;sinc_interp_kaiser&quot;``] (Default: ``&quot;sinc_interp_hann&quot;``)</span>
<span class="sd">        beta (float or None, optional): The shape parameter used for kaiser window.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tensor: The waveform at the new frequency of dimension `(..., time).`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">orig_freq</span> <span class="o">&lt;=</span> <span class="mf">0.0</span> <span class="ow">or</span> <span class="n">new_freq</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Original frequency and desired frequecy should be positive&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">orig_freq</span> <span class="o">==</span> <span class="n">new_freq</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">waveform</span>

    <span class="n">gcd</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">gcd</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">orig_freq</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">new_freq</span><span class="p">))</span>

    <span class="n">kernel</span><span class="p">,</span> <span class="n">width</span> <span class="o">=</span> <span class="n">_get_sinc_resample_kernel</span><span class="p">(</span>
        <span class="n">orig_freq</span><span class="p">,</span>
        <span class="n">new_freq</span><span class="p">,</span>
        <span class="n">gcd</span><span class="p">,</span>
        <span class="n">lowpass_filter_width</span><span class="p">,</span>
        <span class="n">rolloff</span><span class="p">,</span>
        <span class="n">resampling_method</span><span class="p">,</span>
        <span class="n">beta</span><span class="p">,</span>
        <span class="n">waveform</span><span class="o">.</span><span class="n">device</span><span class="p">,</span>
        <span class="n">waveform</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">resampled</span> <span class="o">=</span> <span class="n">_apply_sinc_resample_kernel</span><span class="p">(</span><span class="n">waveform</span><span class="p">,</span> <span class="n">orig_freq</span><span class="p">,</span> <span class="n">new_freq</span><span class="p">,</span> <span class="n">gcd</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">width</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">resampled</span></div>


<div class="viewcode-block" id="edit_distance"><a class="viewcode-back" href="../../../generated/torchaudio.functional.edit_distance.html#torchaudio.functional.edit_distance">[docs]</a><span class="nd">@torch</span><span class="o">.</span><span class="n">jit</span><span class="o">.</span><span class="n">unused</span>
<span class="k">def</span> <span class="nf">edit_distance</span><span class="p">(</span><span class="n">seq1</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">seq2</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the word level edit (Levenshtein) distance between two sequences.</span>

<span class="sd">    .. devices:: CPU</span>

<span class="sd">    The function computes an edit distance allowing deletion, insertion and</span>
<span class="sd">    substitution. The result is an integer.</span>

<span class="sd">    For most applications, the two input sequences should be the same type. If</span>
<span class="sd">    two strings are given, the output is the edit distance between the two</span>
<span class="sd">    strings (character edit distance). If two lists of strings are given, the</span>
<span class="sd">    output is the edit distance between sentences (word edit distance). Users</span>
<span class="sd">    may want to normalize the output by the length of the reference sequence.</span>

<span class="sd">    Args:</span>
<span class="sd">        seq1 (Sequence): the first sequence to compare.</span>
<span class="sd">        seq2 (Sequence): the second sequence to compare.</span>
<span class="sd">    Returns:</span>
<span class="sd">        int: The distance between the first and second sequences.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">len_sent2</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq2</span><span class="p">)</span>
    <span class="n">dold</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">len_sent2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">dnew</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">len_sent2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">dnew</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">len_sent2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">seq1</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">seq2</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="n">dnew</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dold</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">substitution</span> <span class="o">=</span> <span class="n">dold</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">insertion</span> <span class="o">=</span> <span class="n">dnew</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">deletion</span> <span class="o">=</span> <span class="n">dold</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">dnew</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">substitution</span><span class="p">,</span> <span class="n">insertion</span><span class="p">,</span> <span class="n">deletion</span><span class="p">)</span>

        <span class="n">dnew</span><span class="p">,</span> <span class="n">dold</span> <span class="o">=</span> <span class="n">dold</span><span class="p">,</span> <span class="n">dnew</span>

    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">dold</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span></div>


<div class="viewcode-block" id="loudness"><a class="viewcode-back" href="../../../generated/torchaudio.functional.loudness.html#torchaudio.functional.loudness">[docs]</a><span class="k">def</span> <span class="nf">loudness</span><span class="p">(</span><span class="n">waveform</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">sample_rate</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Measure audio loudness according to the ITU-R BS.1770-4 recommendation.</span>

<span class="sd">    .. devices:: CPU CUDA</span>

<span class="sd">    .. properties:: TorchScript</span>

<span class="sd">    Args:</span>
<span class="sd">        waveform(torch.Tensor): audio waveform of dimension `(..., channels, time)`</span>
<span class="sd">        sample_rate (int): sampling rate of the waveform</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tensor: loudness estimates (LKFS)</span>

<span class="sd">    Reference:</span>
<span class="sd">        - https://www.itu.int/rec/R-REC-BS.1770-4-201510-I/en</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">waveform</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Only up to 5 channels are supported.&quot;</span><span class="p">)</span>

    <span class="n">gate_duration</span> <span class="o">=</span> <span class="mf">0.4</span>
    <span class="n">overlap</span> <span class="o">=</span> <span class="mf">0.75</span>
    <span class="n">gamma_abs</span> <span class="o">=</span> <span class="o">-</span><span class="mf">70.0</span>
    <span class="n">kweight_bias</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.691</span>
    <span class="n">gate_samples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">gate_duration</span> <span class="o">*</span> <span class="n">sample_rate</span><span class="p">))</span>
    <span class="n">step</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">gate_samples</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">overlap</span><span class="p">)))</span>

    <span class="c1"># Apply K-weighting</span>
    <span class="n">waveform</span> <span class="o">=</span> <span class="n">treble_biquad</span><span class="p">(</span><span class="n">waveform</span><span class="p">,</span> <span class="n">sample_rate</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">,</span> <span class="mf">1500.0</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
    <span class="n">waveform</span> <span class="o">=</span> <span class="n">highpass_biquad</span><span class="p">(</span><span class="n">waveform</span><span class="p">,</span> <span class="n">sample_rate</span><span class="p">,</span> <span class="mf">38.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>

    <span class="c1"># Compute the energy for each block</span>
    <span class="n">energy</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">waveform</span><span class="p">)</span><span class="o">.</span><span class="n">unfold</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">gate_samples</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
    <span class="n">energy</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">energy</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Compute channel-weighted summation</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.41</span><span class="p">,</span> <span class="mf">1.41</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">waveform</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">waveform</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">g</span><span class="p">[:</span> <span class="n">energy</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)]</span>

    <span class="n">energy_weighted</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">energy</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">loudness</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.691</span> <span class="o">+</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">energy_weighted</span><span class="p">)</span>

    <span class="c1"># Apply absolute gating of the blocks</span>
    <span class="n">gated_blocks</span> <span class="o">=</span> <span class="n">loudness</span> <span class="o">&gt;</span> <span class="n">gamma_abs</span>
    <span class="n">gated_blocks</span> <span class="o">=</span> <span class="n">gated_blocks</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>

    <span class="n">energy_filtered</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">gated_blocks</span> <span class="o">*</span> <span class="n">energy</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">torch</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">gated_blocks</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">energy_weighted</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">g</span> <span class="o">*</span> <span class="n">energy_filtered</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">gamma_rel</span> <span class="o">=</span> <span class="n">kweight_bias</span> <span class="o">+</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">energy_weighted</span><span class="p">)</span> <span class="o">-</span> <span class="mi">10</span>

    <span class="c1"># Apply relative gating of the blocks</span>
    <span class="n">gated_blocks</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">gated_blocks</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">),</span> <span class="n">loudness</span> <span class="o">&gt;</span> <span class="n">gamma_rel</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">gated_blocks</span> <span class="o">=</span> <span class="n">gated_blocks</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>

    <span class="n">energy_filtered</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">gated_blocks</span> <span class="o">*</span> <span class="n">energy</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">torch</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">gated_blocks</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">energy_weighted</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">g</span> <span class="o">*</span> <span class="n">energy_filtered</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">LKFS</span> <span class="o">=</span> <span class="n">kweight_bias</span> <span class="o">+</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">energy_weighted</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">LKFS</span></div>


<div class="viewcode-block" id="pitch_shift"><a class="viewcode-back" href="../../../generated/torchaudio.functional.pitch_shift.html#torchaudio.functional.pitch_shift">[docs]</a><span class="k">def</span> <span class="nf">pitch_shift</span><span class="p">(</span>
    <span class="n">waveform</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
    <span class="n">sample_rate</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">n_steps</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">bins_per_octave</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">12</span><span class="p">,</span>
    <span class="n">n_fft</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">512</span><span class="p">,</span>
    <span class="n">win_length</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">hop_length</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">window</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Shift the pitch of a waveform by ``n_steps`` steps.</span>

<span class="sd">    .. devices:: CPU CUDA</span>

<span class="sd">    .. properties:: TorchScript</span>

<span class="sd">    Args:</span>
<span class="sd">        waveform (Tensor): The input waveform of shape `(..., time)`.</span>
<span class="sd">        sample_rate (int): Sample rate of `waveform`.</span>
<span class="sd">        n_steps (int): The (fractional) steps to shift `waveform`.</span>
<span class="sd">        bins_per_octave (int, optional): The number of steps per octave (Default: ``12``).</span>
<span class="sd">        n_fft (int, optional): Size of FFT, creates ``n_fft // 2 + 1`` bins (Default: ``512``).</span>
<span class="sd">        win_length (int or None, optional): Window size. If None, then ``n_fft`` is used. (Default: ``None``).</span>
<span class="sd">        hop_length (int or None, optional): Length of hop between STFT windows. If None, then</span>
<span class="sd">            ``win_length // 4`` is used (Default: ``None``).</span>
<span class="sd">        window (Tensor or None, optional): Window tensor that is applied/multiplied to each frame/window.</span>
<span class="sd">            If None, then ``torch.hann_window(win_length)`` is used (Default: ``None``).</span>


<span class="sd">    Returns:</span>
<span class="sd">        Tensor: The pitch-shifted audio waveform of shape `(..., time)`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">waveform_stretch</span> <span class="o">=</span> <span class="n">_stretch_waveform</span><span class="p">(</span>
        <span class="n">waveform</span><span class="p">,</span>
        <span class="n">n_steps</span><span class="p">,</span>
        <span class="n">bins_per_octave</span><span class="p">,</span>
        <span class="n">n_fft</span><span class="p">,</span>
        <span class="n">win_length</span><span class="p">,</span>
        <span class="n">hop_length</span><span class="p">,</span>
        <span class="n">window</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">rate</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="nb">float</span><span class="p">(</span><span class="n">n_steps</span><span class="p">)</span> <span class="o">/</span> <span class="n">bins_per_octave</span><span class="p">)</span>
    <span class="n">waveform_shift</span> <span class="o">=</span> <span class="n">resample</span><span class="p">(</span><span class="n">waveform_stretch</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">sample_rate</span> <span class="o">/</span> <span class="n">rate</span><span class="p">),</span> <span class="n">sample_rate</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_fix_waveform_shape</span><span class="p">(</span><span class="n">waveform_shift</span><span class="p">,</span> <span class="n">waveform</span><span class="o">.</span><span class="n">size</span><span class="p">())</span></div>


<span class="k">def</span> <span class="nf">_stretch_waveform</span><span class="p">(</span>
    <span class="n">waveform</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
    <span class="n">n_steps</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">bins_per_octave</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">12</span><span class="p">,</span>
    <span class="n">n_fft</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">512</span><span class="p">,</span>
    <span class="n">win_length</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">hop_length</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">window</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pitch shift helper function to preprocess and stretch waveform before resampling step.</span>

<span class="sd">    Args:</span>
<span class="sd">        See pitch_shift arg descriptions.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tensor: The preprocessed waveform stretched prior to resampling.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">hop_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">hop_length</span> <span class="o">=</span> <span class="n">n_fft</span> <span class="o">//</span> <span class="mi">4</span>
    <span class="k">if</span> <span class="n">win_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">win_length</span> <span class="o">=</span> <span class="n">n_fft</span>
    <span class="k">if</span> <span class="n">window</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">window</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">hann_window</span><span class="p">(</span><span class="n">window_length</span><span class="o">=</span><span class="n">win_length</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">waveform</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

    <span class="c1"># pack batch</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">waveform</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
    <span class="n">waveform</span> <span class="o">=</span> <span class="n">waveform</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="n">ori_len</span> <span class="o">=</span> <span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">rate</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="nb">float</span><span class="p">(</span><span class="n">n_steps</span><span class="p">)</span> <span class="o">/</span> <span class="n">bins_per_octave</span><span class="p">)</span>
    <span class="n">spec_f</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stft</span><span class="p">(</span>
        <span class="nb">input</span><span class="o">=</span><span class="n">waveform</span><span class="p">,</span>
        <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span>
        <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span>
        <span class="n">win_length</span><span class="o">=</span><span class="n">win_length</span><span class="p">,</span>
        <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
        <span class="n">center</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">pad_mode</span><span class="o">=</span><span class="s2">&quot;reflect&quot;</span><span class="p">,</span>
        <span class="n">normalized</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">onesided</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">return_complex</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">phase_advance</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">hop_length</span><span class="p">,</span> <span class="n">spec_f</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">device</span><span class="o">=</span><span class="n">spec_f</span><span class="o">.</span><span class="n">device</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
    <span class="n">spec_stretch</span> <span class="o">=</span> <span class="n">phase_vocoder</span><span class="p">(</span><span class="n">spec_f</span><span class="p">,</span> <span class="n">rate</span><span class="p">,</span> <span class="n">phase_advance</span><span class="p">)</span>
    <span class="n">len_stretch</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">ori_len</span> <span class="o">/</span> <span class="n">rate</span><span class="p">))</span>
    <span class="n">waveform_stretch</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">istft</span><span class="p">(</span>
        <span class="n">spec_stretch</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span> <span class="n">win_length</span><span class="o">=</span><span class="n">win_length</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="n">len_stretch</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">waveform_stretch</span>


<span class="k">def</span> <span class="nf">_fix_waveform_shape</span><span class="p">(</span>
    <span class="n">waveform_shift</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
    <span class="n">shape</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    PitchShift helper function to process after resampling step to fix the shape back.</span>

<span class="sd">    Args:</span>
<span class="sd">        waveform_shift(Tensor): The waveform after stretch and resample</span>
<span class="sd">        shape (List[int]): The shape of initial waveform</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tensor: The pitch-shifted audio waveform of shape `(..., time)`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ori_len</span> <span class="o">=</span> <span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">shift_len</span> <span class="o">=</span> <span class="n">waveform_shift</span><span class="o">.</span><span class="n">size</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">shift_len</span> <span class="o">&gt;</span> <span class="n">ori_len</span><span class="p">:</span>
        <span class="n">waveform_shift</span> <span class="o">=</span> <span class="n">waveform_shift</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="n">ori_len</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">waveform_shift</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">functional</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">waveform_shift</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">ori_len</span> <span class="o">-</span> <span class="n">shift_len</span><span class="p">])</span>

    <span class="c1"># unpack batch</span>
    <span class="n">waveform_shift</span> <span class="o">=</span> <span class="n">waveform_shift</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">waveform_shift</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:])</span>
    <span class="k">return</span> <span class="n">waveform_shift</span>


<div class="viewcode-block" id="rnnt_loss"><a class="viewcode-back" href="../../../generated/torchaudio.functional.rnnt_loss.html#torchaudio.functional.rnnt_loss">[docs]</a><span class="k">def</span> <span class="nf">rnnt_loss</span><span class="p">(</span>
    <span class="n">logits</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
    <span class="n">targets</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
    <span class="n">logit_lengths</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
    <span class="n">target_lengths</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
    <span class="n">blank</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">clamp</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">reduction</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;mean&quot;</span><span class="p">,</span>
    <span class="n">fused_log_softmax</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the RNN Transducer loss from *Sequence Transduction with Recurrent Neural Networks*</span>
<span class="sd">    :cite:`graves2012sequence`.</span>

<span class="sd">    .. devices:: CPU CUDA</span>

<span class="sd">    .. properties:: Autograd TorchScript</span>

<span class="sd">    The RNN Transducer loss extends the CTC loss by defining a distribution over output</span>
<span class="sd">    sequences of all lengths, and by jointly modelling both input-output and output-output</span>
<span class="sd">    dependencies.</span>

<span class="sd">    Args:</span>
<span class="sd">        logits (Tensor): Tensor of dimension `(batch, max seq length, max target length + 1, class)`</span>
<span class="sd">            containing output from joiner</span>
<span class="sd">        targets (Tensor): Tensor of dimension `(batch, max target length)` containing targets with zero padded</span>
<span class="sd">        logit_lengths (Tensor): Tensor of dimension `(batch)` containing lengths of each sequence from encoder</span>
<span class="sd">        target_lengths (Tensor): Tensor of dimension `(batch)` containing lengths of targets for each sequence</span>
<span class="sd">        blank (int, optional): blank label (Default: ``-1``)</span>
<span class="sd">        clamp (float, optional): clamp for gradients (Default: ``-1``)</span>
<span class="sd">        reduction (string, optional): Specifies the reduction to apply to the output:</span>
<span class="sd">            ``&quot;none&quot;`` | ``&quot;mean&quot;`` | ``&quot;sum&quot;``. (Default: ``&quot;mean&quot;``)</span>
<span class="sd">        fused_log_softmax (bool): set to False if calling log_softmax outside of loss (Default: ``True``)</span>
<span class="sd">    Returns:</span>
<span class="sd">        Tensor: Loss with the reduction option applied. If ``reduction`` is  ``&quot;none&quot;``, then size `(batch)`,</span>
<span class="sd">        otherwise scalar.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">reduction</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;none&quot;</span><span class="p">,</span> <span class="s2">&quot;mean&quot;</span><span class="p">,</span> <span class="s2">&quot;sum&quot;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;reduction should be one of &quot;none&quot;, &quot;mean&quot;, or &quot;sum&quot;&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">blank</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># reinterpret blank index if blank &lt; 0.</span>
        <span class="n">blank</span> <span class="o">=</span> <span class="n">logits</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">blank</span>

    <span class="n">costs</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">torchaudio</span><span class="o">.</span><span class="n">rnnt_loss</span><span class="p">(</span>
        <span class="n">logits</span><span class="o">=</span><span class="n">logits</span><span class="p">,</span>
        <span class="n">targets</span><span class="o">=</span><span class="n">targets</span><span class="p">,</span>
        <span class="n">logit_lengths</span><span class="o">=</span><span class="n">logit_lengths</span><span class="p">,</span>
        <span class="n">target_lengths</span><span class="o">=</span><span class="n">target_lengths</span><span class="p">,</span>
        <span class="n">blank</span><span class="o">=</span><span class="n">blank</span><span class="p">,</span>
        <span class="n">clamp</span><span class="o">=</span><span class="n">clamp</span><span class="p">,</span>
        <span class="n">fused_log_softmax</span><span class="o">=</span><span class="n">fused_log_softmax</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">reduction</span> <span class="o">==</span> <span class="s2">&quot;mean&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">costs</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">reduction</span> <span class="o">==</span> <span class="s2">&quot;sum&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">costs</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">costs</span></div>


<div class="viewcode-block" id="psd"><a class="viewcode-back" href="../../../generated/torchaudio.functional.psd.html#torchaudio.functional.psd">[docs]</a><span class="k">def</span> <span class="nf">psd</span><span class="p">(</span>
    <span class="n">specgram</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
    <span class="n">mask</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">normalize</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">eps</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-10</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute cross-channel power spectral density (PSD) matrix.</span>

<span class="sd">    .. devices:: CPU CUDA</span>

<span class="sd">    .. properties:: Autograd TorchScript</span>

<span class="sd">    Args:</span>
<span class="sd">        specgram (torch.Tensor): Multi-channel complex-valued spectrum.</span>
<span class="sd">            Tensor with dimensions `(..., channel, freq, time)`.</span>
<span class="sd">        mask (torch.Tensor or None, optional): Time-Frequency mask for normalization.</span>
<span class="sd">            Tensor with dimensions `(..., freq, time)`. (Default: ``None``)</span>
<span class="sd">        normalize (bool, optional): If ``True``, normalize the mask along the time dimension. (Default: ``True``)</span>
<span class="sd">        eps (float, optional): Value to add to the denominator in mask normalization. (Default: ``1e-15``)</span>

<span class="sd">    Returns:</span>
<span class="sd">        torch.Tensor: The complex-valued PSD matrix of the input spectrum.</span>
<span class="sd">        Tensor with dimensions `(..., freq, channel, channel)`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">specgram</span> <span class="o">=</span> <span class="n">specgram</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># shape (freq, channel, time)</span>
    <span class="c1"># outer product:</span>
    <span class="c1"># (..., ch_1, time) x (..., ch_2, time) -&gt; (..., time, ch_1, ch_2)</span>
    <span class="n">psd</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;...ct,...et-&gt;...tce&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">specgram</span><span class="p">,</span> <span class="n">specgram</span><span class="o">.</span><span class="n">conj</span><span class="p">()])</span>

    <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">specgram</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="ow">or</span> <span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">specgram</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The dimensions of mask except the channel dimension should be the same as specgram.&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Found </span><span class="si">{</span><span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> for mask and </span><span class="si">{</span><span class="n">specgram</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> for specgram.&quot;</span>
            <span class="p">)</span>
        <span class="c1"># Normalized mask along time dimension:</span>
        <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span> <span class="o">/</span> <span class="p">(</span><span class="n">mask</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdim</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">+</span> <span class="n">eps</span><span class="p">)</span>

        <span class="n">psd</span> <span class="o">=</span> <span class="n">psd</span> <span class="o">*</span> <span class="n">mask</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>

    <span class="n">psd</span> <span class="o">=</span> <span class="n">psd</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dim</span><span class="o">=-</span><span class="mi">3</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">psd</span></div>


<span class="k">def</span> <span class="nf">_compute_mat_trace</span><span class="p">(</span><span class="nb">input</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">dim1</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dim2</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Compute the trace of a Tensor along ``dim1`` and ``dim2`` dimensions.</span>

<span class="sd">    Args:</span>
<span class="sd">        input (torch.Tensor): Tensor with dimensions `(..., channel, channel)`.</span>
<span class="sd">        dim1 (int, optional): The first dimension of the diagonal matrix.</span>
<span class="sd">            (Default: ``-1``)</span>
<span class="sd">        dim2 (int, optional): The second dimension of the diagonal matrix.</span>
<span class="sd">            (Default: ``-2``)</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tensor: The trace of the input Tensor.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">input</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The dimension of the tensor must be at least 2.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">input</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">dim1</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">input</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">dim2</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The size of ``dim1`` and ``dim2`` must be the same.&quot;</span><span class="p">)</span>
    <span class="nb">input</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dim1</span><span class="o">=</span><span class="n">dim1</span><span class="p">,</span> <span class="n">dim2</span><span class="o">=</span><span class="n">dim2</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">input</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_tik_reg</span><span class="p">(</span><span class="n">mat</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">reg</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-7</span><span class="p">,</span> <span class="n">eps</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-8</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Perform Tikhonov regularization (only modifying real part).</span>

<span class="sd">    Args:</span>
<span class="sd">        mat (torch.Tensor): Input matrix with dimensions `(..., channel, channel)`.</span>
<span class="sd">        reg (float, optional): Regularization factor. (Default: 1e-8)</span>
<span class="sd">        eps (float, optional): Value to avoid the correlation matrix is all-zero. (Default: ``1e-8``)</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tensor: Regularized matrix with dimensions `(..., channel, channel)`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Add eps</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">eye</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">mat</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">mat</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
    <span class="n">epsilon</span> <span class="o">=</span> <span class="n">_compute_mat_trace</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span><span class="o">.</span><span class="n">real</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">reg</span>
    <span class="c1"># in case that correlation_matrix is all-zero</span>
    <span class="n">epsilon</span> <span class="o">=</span> <span class="n">epsilon</span> <span class="o">+</span> <span class="n">eps</span>
    <span class="n">mat</span> <span class="o">=</span> <span class="n">mat</span> <span class="o">+</span> <span class="n">epsilon</span> <span class="o">*</span> <span class="n">eye</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
    <span class="k">return</span> <span class="n">mat</span>


<span class="k">def</span> <span class="nf">_assert_psd_matrices</span><span class="p">(</span><span class="n">psd_s</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">psd_n</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Assertion checks of the PSD matrices of target speech and noise.</span>

<span class="sd">    Args:</span>
<span class="sd">        psd_s (torch.Tensor): The complex-valued power spectral density (PSD) matrix of target speech.</span>
<span class="sd">            Tensor with dimensions `(..., freq, channel, channel)`.</span>
<span class="sd">        psd_n (torch.Tensor): The complex-valued power spectral density (PSD) matrix of noise.</span>
<span class="sd">            Tensor with dimensions `(..., freq, channel, channel)`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">psd_s</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="ow">or</span> <span class="n">psd_n</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Expected at least 3D Tensor (..., freq, channel, channel) for psd_s and psd_n. &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;Found </span><span class="si">{</span><span class="n">psd_s</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> for psd_s and </span><span class="si">{</span><span class="n">psd_n</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> for psd_n.&quot;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">psd_s</span><span class="o">.</span><span class="n">is_complex</span><span class="p">()</span> <span class="ow">and</span> <span class="n">psd_n</span><span class="o">.</span><span class="n">is_complex</span><span class="p">()):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s2">&quot;The type of psd_s and psd_n must be ``torch.cfloat`` or ``torch.cdouble``. &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;Found </span><span class="si">{</span><span class="n">psd_s</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2"> for psd_s and </span><span class="si">{</span><span class="n">psd_n</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2"> for psd_n.&quot;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">psd_s</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">psd_n</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;The dimensions of psd_s and psd_n should be the same. Found </span><span class="si">{</span><span class="n">psd_s</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">psd_n</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">psd_s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">psd_s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The last two dimensions of psd_s should be the same. Found </span><span class="si">{</span><span class="n">psd_s</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="mvdr_weights_souden"><a class="viewcode-back" href="../../../generated/torchaudio.functional.mvdr_weights_souden.html#torchaudio.functional.mvdr_weights_souden">[docs]</a><span class="k">def</span> <span class="nf">mvdr_weights_souden</span><span class="p">(</span>
    <span class="n">psd_s</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
    <span class="n">psd_n</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
    <span class="n">reference_channel</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">],</span>
    <span class="n">diagonal_loading</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">diag_eps</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-7</span><span class="p">,</span>
    <span class="n">eps</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-8</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Compute the Minimum Variance Distortionless Response (*MVDR* :cite:`capon1969high`) beamforming weights</span>
<span class="sd">    by the method proposed by *Souden et, al.* :cite:`souden2009optimal`.</span>

<span class="sd">    .. devices:: CPU CUDA</span>

<span class="sd">    .. properties:: Autograd TorchScript</span>

<span class="sd">    Given the power spectral density (PSD) matrix of target speech :math:`\bf{\Phi}_{\textbf{SS}}`,</span>
<span class="sd">    the PSD matrix of noise :math:`\bf{\Phi}_{\textbf{NN}}`, and a one-hot vector that represents the</span>
<span class="sd">    reference channel :math:`\bf{u}`, the method computes the MVDR beamforming weight martrix</span>
<span class="sd">    :math:`\textbf{w}_{\text{MVDR}}`. The formula is defined as:</span>

<span class="sd">    .. math::</span>
<span class="sd">        \textbf{w}_{\text{MVDR}}(f) =</span>
<span class="sd">        \frac{{{\bf{\Phi}_{\textbf{NN}}^{-1}}(f){\bf{\Phi}_{\textbf{SS}}}}(f)}</span>
<span class="sd">        {\text{Trace}({{{\bf{\Phi}_{\textbf{NN}}^{-1}}(f) \bf{\Phi}_{\textbf{SS}}}(f))}}\bm{u}</span>

<span class="sd">    Args:</span>
<span class="sd">        psd_s (torch.Tensor): The complex-valued power spectral density (PSD) matrix of target speech.</span>
<span class="sd">            Tensor with dimensions `(..., freq, channel, channel)`.</span>
<span class="sd">        psd_n (torch.Tensor): The complex-valued power spectral density (PSD) matrix of noise.</span>
<span class="sd">            Tensor with dimensions `(..., freq, channel, channel)`.</span>
<span class="sd">        reference_channel (int or torch.Tensor): Specifies the reference channel.</span>
<span class="sd">            If the dtype is ``int``, it represents the reference channel index.</span>
<span class="sd">            If the dtype is ``torch.Tensor``, its shape is `(..., channel)`, where the ``channel`` dimension</span>
<span class="sd">            is one-hot.</span>
<span class="sd">        diagonal_loading (bool, optional): If ``True``, enables applying diagonal loading to ``psd_n``.</span>
<span class="sd">            (Default: ``True``)</span>
<span class="sd">        diag_eps (float, optional): The coefficient multiplied to the identity matrix for diagonal loading.</span>
<span class="sd">            It is only effective when ``diagonal_loading`` is set to ``True``. (Default: ``1e-7``)</span>
<span class="sd">        eps (float, optional): Value to add to the denominator in the beamforming weight formula.</span>
<span class="sd">            (Default: ``1e-8``)</span>

<span class="sd">    Returns:</span>
<span class="sd">        torch.Tensor: The complex-valued MVDR beamforming weight matrix with dimensions `(..., freq, channel)`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_assert_psd_matrices</span><span class="p">(</span><span class="n">psd_s</span><span class="p">,</span> <span class="n">psd_n</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">diagonal_loading</span><span class="p">:</span>
        <span class="n">psd_n</span> <span class="o">=</span> <span class="n">_tik_reg</span><span class="p">(</span><span class="n">psd_n</span><span class="p">,</span> <span class="n">reg</span><span class="o">=</span><span class="n">diag_eps</span><span class="p">)</span>
    <span class="n">numerator</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">psd_n</span><span class="p">,</span> <span class="n">psd_s</span><span class="p">)</span>  <span class="c1"># psd_n.inv() @ psd_s</span>
    <span class="c1"># ws: (..., C, C) / (...,) -&gt; (..., C, C)</span>
    <span class="n">ws</span> <span class="o">=</span> <span class="n">numerator</span> <span class="o">/</span> <span class="p">(</span><span class="n">_compute_mat_trace</span><span class="p">(</span><span class="n">numerator</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">+</span> <span class="n">eps</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">jit</span><span class="o">.</span><span class="n">isinstance</span><span class="p">(</span><span class="n">reference_channel</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">beamform_weights</span> <span class="o">=</span> <span class="n">ws</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="n">reference_channel</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">torch</span><span class="o">.</span><span class="n">jit</span><span class="o">.</span><span class="n">isinstance</span><span class="p">(</span><span class="n">reference_channel</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">):</span>
        <span class="n">reference_channel</span> <span class="o">=</span> <span class="n">reference_channel</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">psd_n</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="c1"># h: (..., F, C_1, C_2) x (..., C_2) -&gt; (..., F, C_1)</span>
        <span class="n">beamform_weights</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;...c,...c-&gt;...&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">ws</span><span class="p">,</span> <span class="n">reference_channel</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:]])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Expected &quot;int&quot; or &quot;Tensor&quot; for reference_channel. Found: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">reference_channel</span><span class="p">)</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">beamform_weights</span></div>


<div class="viewcode-block" id="mvdr_weights_rtf"><a class="viewcode-back" href="../../../generated/torchaudio.functional.mvdr_weights_rtf.html#torchaudio.functional.mvdr_weights_rtf">[docs]</a><span class="k">def</span> <span class="nf">mvdr_weights_rtf</span><span class="p">(</span>
    <span class="n">rtf</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
    <span class="n">psd_n</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
    <span class="n">reference_channel</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">diagonal_loading</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">diag_eps</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-7</span><span class="p">,</span>
    <span class="n">eps</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-8</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Compute the Minimum Variance Distortionless Response (*MVDR* :cite:`capon1969high`) beamforming weights</span>
<span class="sd">    based on the relative transfer function (RTF) and power spectral density (PSD) matrix of noise.</span>

<span class="sd">    .. devices:: CPU CUDA</span>

<span class="sd">    .. properties:: Autograd TorchScript</span>

<span class="sd">    Given the relative transfer function (RTF) matrix or the steering vector of target speech :math:`\bm{v}`,</span>
<span class="sd">    the PSD matrix of noise :math:`\bf{\Phi}_{\textbf{NN}}`, and a one-hot vector that represents the</span>
<span class="sd">    reference channel :math:`\bf{u}`, the method computes the MVDR beamforming weight martrix</span>
<span class="sd">    :math:`\textbf{w}_{\text{MVDR}}`. The formula is defined as:</span>

<span class="sd">    .. math::</span>
<span class="sd">        \textbf{w}_{\text{MVDR}}(f) =</span>
<span class="sd">        \frac{{{\bf{\Phi}_{\textbf{NN}}^{-1}}(f){\bm{v}}(f)}}</span>
<span class="sd">        {{\bm{v}^{\mathsf{H}}}(f){\bf{\Phi}_{\textbf{NN}}^{-1}}(f){\bm{v}}(f)}</span>

<span class="sd">    where :math:`(.)^{\mathsf{H}}` denotes the Hermitian Conjugate operation.</span>

<span class="sd">    Args:</span>
<span class="sd">        rtf (torch.Tensor): The complex-valued RTF vector of target speech.</span>
<span class="sd">            Tensor with dimensions `(..., freq, channel)`.</span>
<span class="sd">        psd_n (torch.Tensor): The complex-valued power spectral density (PSD) matrix of noise.</span>
<span class="sd">            Tensor with dimensions `(..., freq, channel, channel)`.</span>
<span class="sd">        reference_channel (int or torch.Tensor): Specifies the reference channel.</span>
<span class="sd">            If the dtype is ``int``, it represents the reference channel index.</span>
<span class="sd">            If the dtype is ``torch.Tensor``, its shape is `(..., channel)`, where the ``channel`` dimension</span>
<span class="sd">            is one-hot.</span>
<span class="sd">        diagonal_loading (bool, optional): If ``True``, enables applying diagonal loading to ``psd_n``.</span>
<span class="sd">            (Default: ``True``)</span>
<span class="sd">        diag_eps (float, optional): The coefficient multiplied to the identity matrix for diagonal loading.</span>
<span class="sd">            It is only effective when ``diagonal_loading`` is set to ``True``. (Default: ``1e-7``)</span>
<span class="sd">        eps (float, optional): Value to add to the denominator in the beamforming weight formula.</span>
<span class="sd">            (Default: ``1e-8``)</span>

<span class="sd">    Returns:</span>
<span class="sd">        torch.Tensor: The complex-valued MVDR beamforming weight matrix with dimensions `(..., freq, channel)`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">rtf</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Expected at least 2D Tensor (..., freq, channel) for rtf. Found </span><span class="si">{</span><span class="n">rtf</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">psd_n</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Expected at least 3D Tensor (..., freq, channel, channel) for psd_n. Found </span><span class="si">{</span><span class="n">psd_n</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">rtf</span><span class="o">.</span><span class="n">is_complex</span><span class="p">()</span> <span class="ow">and</span> <span class="n">psd_n</span><span class="o">.</span><span class="n">is_complex</span><span class="p">()):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s2">&quot;The type of rtf and psd_n must be ``torch.cfloat`` or ``torch.cdouble``. &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;Found </span><span class="si">{</span><span class="n">rtf</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2"> for rtf and </span><span class="si">{</span><span class="n">psd_n</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2"> for psd_n.&quot;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">rtf</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">psd_n</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;The dimensions of rtf and the dimensions withou the last dimension of psd_n should be the same. &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;Found </span><span class="si">{</span><span class="n">rtf</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> for rtf and </span><span class="si">{</span><span class="n">psd_n</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> for psd_n.&quot;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">psd_n</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">psd_n</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The last two dimensions of psd_n should be the same. Found </span><span class="si">{</span><span class="n">psd_n</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">diagonal_loading</span><span class="p">:</span>
        <span class="n">psd_n</span> <span class="o">=</span> <span class="n">_tik_reg</span><span class="p">(</span><span class="n">psd_n</span><span class="p">,</span> <span class="n">reg</span><span class="o">=</span><span class="n">diag_eps</span><span class="p">)</span>
    <span class="c1"># numerator = psd_n.inv() @ stv</span>
    <span class="n">numerator</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">psd_n</span><span class="p">,</span> <span class="n">rtf</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># (..., freq, channel)</span>
    <span class="c1"># denominator = stv^H @ psd_n.inv() @ stv</span>
    <span class="n">denominator</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;...d,...d-&gt;...&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">rtf</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="n">numerator</span><span class="p">])</span>
    <span class="n">beamform_weights</span> <span class="o">=</span> <span class="n">numerator</span> <span class="o">/</span> <span class="p">(</span><span class="n">denominator</span><span class="o">.</span><span class="n">real</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">eps</span><span class="p">)</span>
    <span class="c1"># normalize the numerator</span>
    <span class="k">if</span> <span class="n">reference_channel</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">jit</span><span class="o">.</span><span class="n">isinstance</span><span class="p">(</span><span class="n">reference_channel</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="n">rtf</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">reference_channel</span><span class="p">]</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">torch</span><span class="o">.</span><span class="n">jit</span><span class="o">.</span><span class="n">isinstance</span><span class="p">(</span><span class="n">reference_channel</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">):</span>
            <span class="n">reference_channel</span> <span class="o">=</span> <span class="n">reference_channel</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">psd_n</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;...c,...c-&gt;...&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">rtf</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="n">reference_channel</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:]])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Expected &quot;int&quot; or &quot;Tensor&quot; for reference_channel. Found: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">reference_channel</span><span class="p">)</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>

        <span class="n">beamform_weights</span> <span class="o">=</span> <span class="n">beamform_weights</span> <span class="o">*</span> <span class="n">scale</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">beamform_weights</span></div>


<div class="viewcode-block" id="rtf_evd"><a class="viewcode-back" href="../../../generated/torchaudio.functional.rtf_evd.html#torchaudio.functional.rtf_evd">[docs]</a><span class="k">def</span> <span class="nf">rtf_evd</span><span class="p">(</span><span class="n">psd_s</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Estimate the relative transfer function (RTF) or the steering vector by eigenvalue decomposition.</span>

<span class="sd">    .. devices:: CPU CUDA</span>

<span class="sd">    .. properties:: TorchScript</span>

<span class="sd">    Args:</span>
<span class="sd">        psd_s (Tensor): The complex-valued power spectral density (PSD) matrix of target speech.</span>
<span class="sd">            Tensor of dimension `(..., freq, channel, channel)`</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tensor: The estimated complex-valued RTF of target speech.</span>
<span class="sd">        Tensor of dimension `(..., freq, channel)`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">psd_s</span><span class="o">.</span><span class="n">is_complex</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The type of psd_s must be ``torch.cfloat`` or ``torch.cdouble``. Found </span><span class="si">{</span><span class="n">psd_s</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">psd_s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">psd_s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The last two dimensions of psd_s should be the same. Found </span><span class="si">{</span><span class="n">psd_s</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">psd_s</span><span class="p">)</span>  <span class="c1"># v is sorted along with eigenvalues in ascending order</span>
    <span class="n">rtf</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># choose the eigenvector with max eigenvalue</span>
    <span class="k">return</span> <span class="n">rtf</span></div>


<div class="viewcode-block" id="rtf_power"><a class="viewcode-back" href="../../../generated/torchaudio.functional.rtf_power.html#torchaudio.functional.rtf_power">[docs]</a><span class="k">def</span> <span class="nf">rtf_power</span><span class="p">(</span>
    <span class="n">psd_s</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
    <span class="n">psd_n</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
    <span class="n">reference_channel</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">],</span>
    <span class="n">n_iter</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
    <span class="n">diagonal_loading</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">diag_eps</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-7</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Estimate the relative transfer function (RTF) or the steering vector by the power method.</span>

<span class="sd">    .. devices:: CPU CUDA</span>

<span class="sd">    .. properties:: Autograd TorchScript</span>

<span class="sd">    Args:</span>
<span class="sd">        psd_s (torch.Tensor): The complex-valued power spectral density (PSD) matrix of target speech.</span>
<span class="sd">            Tensor with dimensions `(..., freq, channel, channel)`.</span>
<span class="sd">        psd_n (torch.Tensor): The complex-valued power spectral density (PSD) matrix of noise.</span>
<span class="sd">            Tensor with dimensions `(..., freq, channel, channel)`.</span>
<span class="sd">        reference_channel (int or torch.Tensor): Specifies the reference channel.</span>
<span class="sd">            If the dtype is ``int``, it represents the reference channel index.</span>
<span class="sd">            If the dtype is ``torch.Tensor``, its shape is `(..., channel)`, where the ``channel`` dimension</span>
<span class="sd">            is one-hot.</span>
<span class="sd">        diagonal_loading (bool, optional): If ``True``, enables applying diagonal loading to ``psd_n``.</span>
<span class="sd">            (Default: ``True``)</span>
<span class="sd">        diag_eps (float, optional): The coefficient multiplied to the identity matrix for diagonal loading.</span>
<span class="sd">            It is only effective when ``diagonal_loading`` is set to ``True``. (Default: ``1e-7``)</span>

<span class="sd">    Returns:</span>
<span class="sd">        torch.Tensor: The estimated complex-valued RTF of target speech.</span>
<span class="sd">        Tensor of dimension `(..., freq, channel)`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_assert_psd_matrices</span><span class="p">(</span><span class="n">psd_s</span><span class="p">,</span> <span class="n">psd_n</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n_iter</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The number of iteration must be greater than 0.&quot;</span><span class="p">)</span>

    <span class="c1"># Apply diagonal loading to psd_n to improve robustness.</span>
    <span class="k">if</span> <span class="n">diagonal_loading</span><span class="p">:</span>
        <span class="n">psd_n</span> <span class="o">=</span> <span class="n">_tik_reg</span><span class="p">(</span><span class="n">psd_n</span><span class="p">,</span> <span class="n">reg</span><span class="o">=</span><span class="n">diag_eps</span><span class="p">)</span>
    <span class="c1"># phi is regarded as the first iteration</span>
    <span class="n">phi</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">psd_n</span><span class="p">,</span> <span class="n">psd_s</span><span class="p">)</span>  <span class="c1"># psd_n.inv() @ psd_s</span>
    <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">jit</span><span class="o">.</span><span class="n">isinstance</span><span class="p">(</span><span class="n">reference_channel</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">rtf</span> <span class="o">=</span> <span class="n">phi</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">reference_channel</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">torch</span><span class="o">.</span><span class="n">jit</span><span class="o">.</span><span class="n">isinstance</span><span class="p">(</span><span class="n">reference_channel</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">):</span>
        <span class="n">reference_channel</span> <span class="o">=</span> <span class="n">reference_channel</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">psd_n</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">rtf</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;...c,...c-&gt;...&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">phi</span><span class="p">,</span> <span class="n">reference_channel</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:]])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Expected &quot;int&quot; or &quot;Tensor&quot; for reference_channel. Found: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">reference_channel</span><span class="p">)</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
    <span class="n">rtf</span> <span class="o">=</span> <span class="n">rtf</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># (..., freq, channel, 1)</span>
    <span class="k">if</span> <span class="n">n_iter</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="c1"># The number of iterations in the for loop is `n_iter - 2`</span>
        <span class="c1"># because the `phi` above and `torch.matmul(psd_s, rtf)` are regarded as</span>
        <span class="c1"># two iterations.</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_iter</span> <span class="o">-</span> <span class="mi">2</span><span class="p">):</span>
            <span class="n">rtf</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">rtf</span><span class="p">)</span>
        <span class="n">rtf</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">psd_s</span><span class="p">,</span> <span class="n">rtf</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># if there is only one iteration, the rtf is the psd_s[..., referenc_channel]</span>
        <span class="c1"># which is psd_n @ phi @ ref_channel</span>
        <span class="n">rtf</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">psd_n</span><span class="p">,</span> <span class="n">rtf</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">rtf</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span></div>


<div class="viewcode-block" id="apply_beamforming"><a class="viewcode-back" href="../../../generated/torchaudio.functional.apply_beamforming.html#torchaudio.functional.apply_beamforming">[docs]</a><span class="k">def</span> <span class="nf">apply_beamforming</span><span class="p">(</span><span class="n">beamform_weights</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">specgram</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Apply the beamforming weight to the multi-channel noisy spectrum to obtain the single-channel enhanced spectrum.</span>

<span class="sd">    .. devices:: CPU CUDA</span>

<span class="sd">    .. properties:: Autograd TorchScript</span>

<span class="sd">    .. math::</span>
<span class="sd">        \hat{\textbf{S}}(f) = \textbf{w}_{\text{bf}}(f)^{\mathsf{H}} \textbf{Y}(f)</span>

<span class="sd">    where :math:`\textbf{w}_{\text{bf}}(f)` is the beamforming weight for the :math:`f`-th frequency bin,</span>
<span class="sd">    :math:`\textbf{Y}` is the multi-channel spectrum for the :math:`f`-th frequency bin.</span>

<span class="sd">    Args:</span>
<span class="sd">        beamform_weights (Tensor): The complex-valued beamforming weight matrix.</span>
<span class="sd">            Tensor of dimension `(..., freq, channel)`</span>
<span class="sd">        specgram (Tensor): The multi-channel complex-valued noisy spectrum.</span>
<span class="sd">            Tensor of dimension `(..., channel, freq, time)`</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tensor: The single-channel complex-valued enhanced spectrum.</span>
<span class="sd">            Tensor of dimension `(..., freq, time)`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">beamform_weights</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="n">specgram</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">3</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;The dimensions except the last two dimensions of beamform_weights should be the same &quot;</span>
            <span class="s2">&quot;as the dimensions except the last three dimensions of specgram. &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;Found </span><span class="si">{</span><span class="n">beamform_weights</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> for beamform_weights and </span><span class="si">{</span><span class="n">specgram</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> for specgram.&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">beamform_weights</span><span class="o">.</span><span class="n">is_complex</span><span class="p">()</span> <span class="ow">and</span> <span class="n">specgram</span><span class="o">.</span><span class="n">is_complex</span><span class="p">()):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s2">&quot;The type of beamform_weights and specgram must be ``torch.cfloat`` or ``torch.cdouble``. &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;Found </span><span class="si">{</span><span class="n">beamform_weights</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2"> for beamform_weights and </span><span class="si">{</span><span class="n">specgram</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2"> for specgram.&quot;</span>
        <span class="p">)</span>

    <span class="c1"># (..., freq, channel) x (..., channel, freq, time) -&gt; (..., freq, time)</span>
    <span class="n">specgram_enhanced</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;...fc,...cft-&gt;...ft&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">beamform_weights</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="n">specgram</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">specgram_enhanced</span></div>


<span class="k">def</span> <span class="nf">_check_shape_compatible</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="n">y</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The operands must be the same dimension (got </span><span class="si">{</span><span class="n">x</span><span class="o">.</span><span class="n">ndim</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">y</span><span class="o">.</span><span class="n">ndim</span><span class="si">}</span><span class="s2">).&quot;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">xi</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">yi</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">xi</span> <span class="o">==</span> <span class="n">yi</span> <span class="ow">or</span> <span class="n">xi</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">yi</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Leading dimensions of x and y are not broadcastable (got </span><span class="si">{</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">).&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_check_convolve_mode</span><span class="p">(</span><span class="n">mode</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">valid_convolve_modes</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;full&quot;</span><span class="p">,</span> <span class="s2">&quot;valid&quot;</span><span class="p">,</span> <span class="s2">&quot;same&quot;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">valid_convolve_modes</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unrecognized mode value &#39;</span><span class="si">{</span><span class="n">mode</span><span class="si">}</span><span class="s2">&#39;. Please specify one of </span><span class="si">{</span><span class="n">valid_convolve_modes</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_apply_convolve_mode</span><span class="p">(</span><span class="n">conv_result</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">x_length</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">y_length</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
    <span class="n">valid_convolve_modes</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;full&quot;</span><span class="p">,</span> <span class="s2">&quot;valid&quot;</span><span class="p">,</span> <span class="s2">&quot;same&quot;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;full&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">conv_result</span>
    <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;valid&quot;</span><span class="p">:</span>
        <span class="n">target_length</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">x_length</span><span class="p">,</span> <span class="n">y_length</span><span class="p">)</span> <span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">x_length</span><span class="p">,</span> <span class="n">y_length</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">start_idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">conv_result</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">target_length</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="k">return</span> <span class="n">conv_result</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">start_idx</span> <span class="p">:</span> <span class="n">start_idx</span> <span class="o">+</span> <span class="n">target_length</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;same&quot;</span><span class="p">:</span>
        <span class="n">start_idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">conv_result</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">x_length</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="k">return</span> <span class="n">conv_result</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">start_idx</span> <span class="p">:</span> <span class="n">start_idx</span> <span class="o">+</span> <span class="n">x_length</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unrecognized mode value &#39;</span><span class="si">{</span><span class="n">mode</span><span class="si">}</span><span class="s2">&#39;. Please specify one of </span><span class="si">{</span><span class="n">valid_convolve_modes</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="fftconvolve"><a class="viewcode-back" href="../../../generated/torchaudio.functional.fftconvolve.html#torchaudio.functional.fftconvolve">[docs]</a><span class="k">def</span> <span class="nf">fftconvolve</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;full&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convolves inputs along their last dimension using FFT. For inputs with large last dimensions, this function</span>
<span class="sd">    is generally much faster than :meth:`convolve`.</span>
<span class="sd">    Note that, in contrast to :meth:`torch.nn.functional.conv1d`, which actually applies the valid cross-correlation</span>
<span class="sd">    operator, this function applies the true `convolution`_ operator.</span>
<span class="sd">    Also note that this function can only output float tensors (int tensor inputs will be cast to float).</span>

<span class="sd">    .. devices:: CPU CUDA</span>

<span class="sd">    .. properties:: Autograd TorchScript</span>

<span class="sd">    Args:</span>
<span class="sd">        x (torch.Tensor): First convolution operand, with shape `(..., N)`.</span>
<span class="sd">        y (torch.Tensor): Second convolution operand, with shape `(..., M)`</span>
<span class="sd">            (leading dimensions must be broadcast-able with those of ``x``).</span>
<span class="sd">        mode (str, optional): Must be one of (&quot;full&quot;, &quot;valid&quot;, &quot;same&quot;).</span>

<span class="sd">            * &quot;full&quot;: Returns the full convolution result, with shape `(..., N + M - 1)`. (Default)</span>
<span class="sd">            * &quot;valid&quot;: Returns the segment of the full convolution result corresponding to where</span>
<span class="sd">              the two inputs overlap completely, with shape `(..., max(N, M) - min(N, M) + 1)`.</span>
<span class="sd">            * &quot;same&quot;: Returns the center segment of the full convolution result, with shape `(..., N)`.</span>

<span class="sd">    Returns:</span>
<span class="sd">        torch.Tensor: Result of convolving ``x`` and ``y``, with shape `(..., L)`, where</span>
<span class="sd">        the leading dimensions match those of ``x`` and `L` is dictated by ``mode``.</span>

<span class="sd">    .. _convolution:</span>
<span class="sd">        https://en.wikipedia.org/wiki/Convolution</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_check_shape_compatible</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="n">_check_convolve_mode</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>

    <span class="n">n</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">y</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">fresult</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfft</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfft</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">irfft</span><span class="p">(</span><span class="n">fresult</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_apply_convolve_mode</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">y</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">mode</span><span class="p">)</span></div>


<div class="viewcode-block" id="convolve"><a class="viewcode-back" href="../../../generated/torchaudio.functional.convolve.html#torchaudio.functional.convolve">[docs]</a><span class="k">def</span> <span class="nf">convolve</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;full&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convolves inputs along their last dimension using the direct method.</span>
<span class="sd">    Note that, in contrast to :meth:`torch.nn.functional.conv1d`, which actually applies the valid cross-correlation</span>
<span class="sd">    operator, this function applies the true `convolution`_ operator.</span>

<span class="sd">    .. devices:: CPU CUDA</span>

<span class="sd">    .. properties:: Autograd TorchScript</span>

<span class="sd">    Args:</span>
<span class="sd">        x (torch.Tensor): First convolution operand, with shape `(..., N)`.</span>
<span class="sd">        y (torch.Tensor): Second convolution operand, with shape `(..., M)`</span>
<span class="sd">            (leading dimensions must be broadcast-able with those of ``x``).</span>
<span class="sd">        mode (str, optional): Must be one of (&quot;full&quot;, &quot;valid&quot;, &quot;same&quot;).</span>

<span class="sd">            * &quot;full&quot;: Returns the full convolution result, with shape `(..., N + M - 1)`. (Default)</span>
<span class="sd">            * &quot;valid&quot;: Returns the segment of the full convolution result corresponding to where</span>
<span class="sd">              the two inputs overlap completely, with shape `(..., max(N, M) - min(N, M) + 1)`.</span>
<span class="sd">            * &quot;same&quot;: Returns the center segment of the full convolution result, with shape `(..., N)`.</span>

<span class="sd">    Returns:</span>
<span class="sd">        torch.Tensor: Result of convolving ``x`` and ``y``, with shape `(..., L)`, where</span>
<span class="sd">        the leading dimensions match those of ``x`` and `L` is dictated by ``mode``.</span>

<span class="sd">    .. _convolution:</span>
<span class="sd">        https://en.wikipedia.org/wiki/Convolution</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_check_shape_compatible</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="n">_check_convolve_mode</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>

    <span class="n">x_size</span><span class="p">,</span> <span class="n">y_size</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">y</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">y</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span>

    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">new_shape</span> <span class="o">=</span> <span class="p">[</span><span class="nb">max</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])]</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">new_shape</span> <span class="o">+</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">new_shape</span> <span class="o">+</span> <span class="p">[</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>

    <span class="n">num_signals</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">prod</span><span class="p">()</span>
    <span class="n">reshaped_x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="nb">int</span><span class="p">(</span><span class="n">num_signals</span><span class="p">),</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)))</span>
    <span class="n">reshaped_y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="nb">int</span><span class="p">(</span><span class="n">num_signals</span><span class="p">),</span> <span class="n">y</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)))</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">functional</span><span class="o">.</span><span class="n">conv1d</span><span class="p">(</span>
        <span class="nb">input</span><span class="o">=</span><span class="n">reshaped_x</span><span class="p">,</span>
        <span class="n">weight</span><span class="o">=</span><span class="n">reshaped_y</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
        <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">groups</span><span class="o">=</span><span class="n">reshaped_x</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
        <span class="n">padding</span><span class="o">=</span><span class="n">reshaped_y</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">output_shape</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">output_shape</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_apply_convolve_mode</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">x_size</span><span class="p">,</span> <span class="n">y_size</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span></div>


<div class="viewcode-block" id="add_noise"><a class="viewcode-back" href="../../../generated/torchaudio.functional.add_noise.html#torchaudio.functional.add_noise">[docs]</a><span class="k">def</span> <span class="nf">add_noise</span><span class="p">(</span>
    <span class="n">waveform</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">noise</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">snr</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">lengths</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Scales and adds noise to waveform per signal-to-noise ratio.</span>

<span class="sd">    Specifically, for each pair of waveform vector :math:`x \in \mathbb{R}^L` and noise vector</span>
<span class="sd">    :math:`n \in \mathbb{R}^L`, the function computes output :math:`y` as</span>

<span class="sd">    .. math::</span>
<span class="sd">        y = x + a n \, \text{,}</span>

<span class="sd">    where</span>

<span class="sd">    .. math::</span>
<span class="sd">        a = \sqrt{ \frac{ ||x||_{2}^{2} }{ ||n||_{2}^{2} } \cdot 10^{-\frac{\text{SNR}}{10}} } \, \text{,}</span>

<span class="sd">    with :math:`\text{SNR}` being the desired signal-to-noise ratio between :math:`x` and :math:`n`, in dB.</span>

<span class="sd">    Note that this function broadcasts singleton leading dimensions in its inputs in a manner that is</span>
<span class="sd">    consistent with the above formulae and PyTorch&#39;s broadcasting semantics.</span>

<span class="sd">    .. devices:: CPU CUDA</span>

<span class="sd">    .. properties:: Autograd TorchScript</span>

<span class="sd">    Args:</span>
<span class="sd">        waveform (torch.Tensor): Input waveform, with shape `(..., L)`.</span>
<span class="sd">        noise (torch.Tensor): Noise, with shape `(..., L)` (same shape as ``waveform``).</span>
<span class="sd">        snr (torch.Tensor): Signal-to-noise ratios in dB, with shape `(...,)`.</span>
<span class="sd">        lengths (torch.Tensor or None, optional): Valid lengths of signals in ``waveform`` and ``noise``, with shape</span>
<span class="sd">            `(...,)` (leading dimensions must match those of ``waveform``). If ``None``, all elements in ``waveform``</span>
<span class="sd">            and ``noise`` are treated as valid. (Default: ``None``)</span>

<span class="sd">    Returns:</span>
<span class="sd">        torch.Tensor: Result of scaling and adding ``noise`` to ``waveform``, with shape `(..., L)`</span>
<span class="sd">        (same shape as ``waveform``).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">waveform</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">noise</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">snr</span><span class="o">.</span><span class="n">ndim</span> <span class="ow">and</span> <span class="p">(</span><span class="n">lengths</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">lengths</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="n">snr</span><span class="o">.</span><span class="n">ndim</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input leading dimensions don&#39;t match.&quot;</span><span class="p">)</span>

    <span class="n">L</span> <span class="o">=</span> <span class="n">waveform</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">L</span> <span class="o">!=</span> <span class="n">noise</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Length dimensions of waveform and noise don&#39;t match (got </span><span class="si">{</span><span class="n">L</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">noise</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="si">}</span><span class="s2">).&quot;</span><span class="p">)</span>

    <span class="c1"># compute scale</span>
    <span class="k">if</span> <span class="n">lengths</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">lengths</span><span class="o">.</span><span class="n">device</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">waveform</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">lengths</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span>
            <span class="o">-</span><span class="mi">1</span>
        <span class="p">)</span>  <span class="c1"># (*, L) &lt; (*, 1) = (*, L)</span>
        <span class="n">masked_waveform</span> <span class="o">=</span> <span class="n">waveform</span> <span class="o">*</span> <span class="n">mask</span>
        <span class="n">masked_noise</span> <span class="o">=</span> <span class="n">noise</span> <span class="o">*</span> <span class="n">mask</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">masked_waveform</span> <span class="o">=</span> <span class="n">waveform</span>
        <span class="n">masked_noise</span> <span class="o">=</span> <span class="n">noise</span>

    <span class="n">energy_signal</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">vector_norm</span><span class="p">(</span><span class="n">masked_waveform</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>  <span class="c1"># (*,)</span>
    <span class="n">energy_noise</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">vector_norm</span><span class="p">(</span><span class="n">masked_noise</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>  <span class="c1"># (*,)</span>
    <span class="n">original_snr_db</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">energy_signal</span><span class="p">)</span> <span class="o">-</span> <span class="n">torch</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">energy_noise</span><span class="p">))</span>
    <span class="n">scale</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">((</span><span class="n">original_snr_db</span> <span class="o">-</span> <span class="n">snr</span><span class="p">)</span> <span class="o">/</span> <span class="mf">20.0</span><span class="p">)</span>  <span class="c1"># (*,)</span>

    <span class="c1"># scale noise</span>
    <span class="n">scaled_noise</span> <span class="o">=</span> <span class="n">scale</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">noise</span>  <span class="c1"># (*, 1) * (*, L) = (*, L)</span>

    <span class="k">return</span> <span class="n">waveform</span> <span class="o">+</span> <span class="n">scaled_noise</span>  <span class="c1"># (*, L)</span></div>


<div class="viewcode-block" id="speed"><a class="viewcode-back" href="../../../generated/torchaudio.functional.speed.html#torchaudio.functional.speed">[docs]</a><span class="k">def</span> <span class="nf">speed</span><span class="p">(</span>
    <span class="n">waveform</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">orig_freq</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">factor</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">lengths</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]]:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Adjusts waveform speed.</span>

<span class="sd">    .. devices:: CPU CUDA</span>

<span class="sd">    .. properties:: Autograd TorchScript</span>

<span class="sd">    Args:</span>
<span class="sd">        waveform (torch.Tensor): Input signals, with shape `(..., time)`.</span>
<span class="sd">        orig_freq (int): Original frequency of the signals in ``waveform``.</span>
<span class="sd">        factor (float): Factor by which to adjust speed of input. Values greater than 1.0</span>
<span class="sd">            compress ``waveform`` in time, whereas values less than 1.0 stretch ``waveform`` in time.</span>
<span class="sd">        lengths (torch.Tensor or None, optional): Valid lengths of signals in ``waveform``, with shape `(...)`.</span>
<span class="sd">            If ``None``, all elements in ``waveform`` are treated as valid. (Default: ``None``)</span>

<span class="sd">    Returns:</span>
<span class="sd">        (torch.Tensor, torch.Tensor or None):</span>
<span class="sd">            torch.Tensor</span>
<span class="sd">                Speed-adjusted waveform, with shape `(..., new_time).`</span>
<span class="sd">            torch.Tensor or None</span>
<span class="sd">                If ``lengths`` is not ``None``, valid lengths of signals in speed-adjusted waveform,</span>
<span class="sd">                with shape `(...)`; otherwise, ``None``.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">source_sample_rate</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">factor</span> <span class="o">*</span> <span class="n">orig_freq</span><span class="p">)</span>
    <span class="n">target_sample_rate</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">orig_freq</span><span class="p">)</span>

    <span class="n">gcd</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">gcd</span><span class="p">(</span><span class="n">source_sample_rate</span><span class="p">,</span> <span class="n">target_sample_rate</span><span class="p">)</span>
    <span class="n">source_sample_rate</span> <span class="o">=</span> <span class="n">source_sample_rate</span> <span class="o">//</span> <span class="n">gcd</span>
    <span class="n">target_sample_rate</span> <span class="o">=</span> <span class="n">target_sample_rate</span> <span class="o">//</span> <span class="n">gcd</span>

    <span class="k">if</span> <span class="n">lengths</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">out_lengths</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">out_lengths</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">lengths</span> <span class="o">*</span> <span class="n">target_sample_rate</span> <span class="o">/</span> <span class="n">source_sample_rate</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">lengths</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">resample</span><span class="p">(</span><span class="n">waveform</span><span class="p">,</span> <span class="n">source_sample_rate</span><span class="p">,</span> <span class="n">target_sample_rate</span><span class="p">),</span> <span class="n">out_lengths</span></div>


<div class="viewcode-block" id="preemphasis"><a class="viewcode-back" href="../../../generated/torchaudio.functional.preemphasis.html#torchaudio.functional.preemphasis">[docs]</a><span class="k">def</span> <span class="nf">preemphasis</span><span class="p">(</span><span class="n">waveform</span><span class="p">,</span> <span class="n">coeff</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.97</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Pre-emphasizes a waveform along its last dimension, i.e.</span>
<span class="sd">    for each signal :math:`x` in ``waveform``, computes</span>
<span class="sd">    output :math:`y` as</span>

<span class="sd">    .. math::</span>
<span class="sd">        y[i] = x[i] - \text{coeff} \cdot x[i - 1]</span>

<span class="sd">    .. devices:: CPU CUDA</span>

<span class="sd">    .. properties:: Autograd TorchScript</span>

<span class="sd">    Args:</span>
<span class="sd">        waveform (torch.Tensor): Waveform, with shape `(..., N)`.</span>
<span class="sd">        coeff (float, optional): Pre-emphasis coefficient. Typically between 0.0 and 1.0.</span>
<span class="sd">            (Default: 0.97)</span>

<span class="sd">    Returns:</span>
<span class="sd">        torch.Tensor: Pre-emphasized waveform, with shape `(..., N)`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">waveform</span> <span class="o">=</span> <span class="n">waveform</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
    <span class="n">waveform</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">-=</span> <span class="n">coeff</span> <span class="o">*</span> <span class="n">waveform</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">waveform</span></div>


<div class="viewcode-block" id="deemphasis"><a class="viewcode-back" href="../../../generated/torchaudio.functional.deemphasis.html#torchaudio.functional.deemphasis">[docs]</a><span class="k">def</span> <span class="nf">deemphasis</span><span class="p">(</span><span class="n">waveform</span><span class="p">,</span> <span class="n">coeff</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.97</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;De-emphasizes a waveform along its last dimension.</span>
<span class="sd">    Inverse of :meth:`preemphasis`. Concretely, for each signal</span>
<span class="sd">    :math:`x` in ``waveform``, computes output :math:`y` as</span>

<span class="sd">    .. math::</span>
<span class="sd">        y[i] = x[i] + \text{coeff} \cdot y[i - 1]</span>

<span class="sd">    .. devices:: CPU CUDA</span>

<span class="sd">    .. properties:: Autograd TorchScript</span>

<span class="sd">    Args:</span>
<span class="sd">        waveform (torch.Tensor): Waveform, with shape `(..., N)`.</span>
<span class="sd">        coeff (float, optional): De-emphasis coefficient. Typically between 0.0 and 1.0.</span>
<span class="sd">            (Default: 0.97)</span>

<span class="sd">    Returns:</span>
<span class="sd">        torch.Tensor: De-emphasized waveform, with shape `(..., N)`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a_coeffs</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="n">coeff</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">waveform</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">waveform</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
    <span class="n">b_coeffs</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">waveform</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">waveform</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">torchaudio</span><span class="o">.</span><span class="n">functional</span><span class="o">.</span><span class="n">lfilter</span><span class="p">(</span><span class="n">waveform</span><span class="p">,</span> <span class="n">a_coeffs</span><span class="o">=</span><span class="n">a_coeffs</span><span class="p">,</span> <span class="n">b_coeffs</span><span class="o">=</span><span class="n">b_coeffs</span><span class="p">)</span></div>


<div class="viewcode-block" id="frechet_distance"><a class="viewcode-back" href="../../../generated/torchaudio.functional.frechet_distance.html#torchaudio.functional.frechet_distance">[docs]</a><span class="k">def</span> <span class="nf">frechet_distance</span><span class="p">(</span><span class="n">mu_x</span><span class="p">,</span> <span class="n">sigma_x</span><span class="p">,</span> <span class="n">mu_y</span><span class="p">,</span> <span class="n">sigma_y</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Computes the FrÃ©chet distance between two multivariate normal distributions :cite:`dowson1982frechet`.</span>

<span class="sd">    Concretely, for multivariate Gaussians :math:`X(\mu_X, \Sigma_X)`</span>
<span class="sd">    and :math:`Y(\mu_Y, \Sigma_Y)`, the function computes and returns :math:`F` as</span>

<span class="sd">    .. math::</span>
<span class="sd">        F(X, Y) = || \mu_X - \mu_Y ||_2^2</span>
<span class="sd">        + \text{Tr}\left( \Sigma_X + \Sigma_Y - 2 \sqrt{\Sigma_X \Sigma_Y} \right)</span>

<span class="sd">    Args:</span>
<span class="sd">        mu_x (torch.Tensor): mean :math:`\mu_X` of multivariate Gaussian :math:`X`, with shape `(N,)`.</span>
<span class="sd">        sigma_x (torch.Tensor): covariance matrix :math:`\Sigma_X` of :math:`X`, with shape `(N, N)`.</span>
<span class="sd">        mu_y (torch.Tensor): mean :math:`\mu_Y` of multivariate Gaussian :math:`Y`, with shape `(N,)`.</span>
<span class="sd">        sigma_y (torch.Tensor): covariance matrix :math:`\Sigma_Y` of :math:`Y`, with shape `(N, N)`.</span>

<span class="sd">    Returns:</span>
<span class="sd">        torch.Tensor: the FrÃ©chet distance between :math:`X` and :math:`Y`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mu_x</span><span class="o">.</span><span class="n">size</span><span class="p">())</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Input mu_x must be one-dimensional; got dimension </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">mu_x</span><span class="o">.</span><span class="n">size</span><span class="p">())</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sigma_x</span><span class="o">.</span><span class="n">size</span><span class="p">())</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Input sigma_x must be two-dimensional; got dimension </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">sigma_x</span><span class="o">.</span><span class="n">size</span><span class="p">())</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sigma_x</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">!=</span> <span class="n">sigma_x</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="n">mu_x</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Each of sigma_x&#39;s dimensions must match mu_x&#39;s size.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">mu_x</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">!=</span> <span class="n">mu_y</span><span class="o">.</span><span class="n">size</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Inputs mu_x and mu_y must have the same shape; got </span><span class="si">{</span><span class="n">mu_x</span><span class="o">.</span><span class="n">size</span><span class="p">()</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">mu_y</span><span class="o">.</span><span class="n">size</span><span class="p">()</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sigma_x</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">!=</span> <span class="n">sigma_y</span><span class="o">.</span><span class="n">size</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Inputs sigma_x and sigma_y must have the same shape; got </span><span class="si">{</span><span class="n">sigma_x</span><span class="o">.</span><span class="n">size</span><span class="p">()</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">sigma_y</span><span class="o">.</span><span class="n">size</span><span class="p">()</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="p">)</span>

    <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">mu_x</span> <span class="o">-</span> <span class="n">mu_y</span><span class="p">)</span><span class="o">.</span><span class="n">square</span><span class="p">()</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">sigma_x</span><span class="o">.</span><span class="n">trace</span><span class="p">()</span> <span class="o">+</span> <span class="n">sigma_y</span><span class="o">.</span><span class="n">trace</span><span class="p">()</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigvals</span><span class="p">(</span><span class="n">sigma_x</span> <span class="o">@</span> <span class="n">sigma_y</span><span class="p">)</span><span class="o">.</span><span class="n">sqrt</span><span class="p">()</span><span class="o">.</span><span class="n">real</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">c</span></div>
</pre></div>

             </article>
             
            </div>
            <footer>
  

  

    <hr>

  

  <div role="contentinfo">
    <p>
        &copy; Copyright 2024, Torchaudio Contributors.

    </p>
  </div>
    
      <div>
        Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
      </div>
     

</footer>

          </div>


        </div>

        <div class="pytorch-content-right" id="pytorch-content-right">
          <div class="pytorch-right-menu" id="pytorch-right-menu">
            <div class="pytorch-side-scroll" id="pytorch-side-scroll-right">
              
            </div>
          </div>
        </div>
      </section>
    </div>

  


  

     
       <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
         <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
         <script src="../../../_static/jquery.js"></script>
         <script src="../../../_static/underscore.js"></script>
         <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
         <script src="../../../_static/doctools.js"></script>
         <script src="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.js"></script>
         <script src="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/contrib/auto-render.min.js"></script>
         <script src="../../../_static/katex_autorenderer.js"></script>
     

  

  <script type="text/javascript" src="../../../_static/js/vendor/popper.min.js"></script>
  <script type="text/javascript" src="../../../_static/js/vendor/bootstrap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/list.js/1.5.0/list.min.js"></script>
  <script type="text/javascript" src="../../../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
    <script type="text/javascript">
    var collapsedSections = ['API Tutorials', 'Pipeline Tutorials', 'Training Recipes']
    </script>
     
    <script type="text/javascript">
      $(document).ready(function() {
	  var downloadNote = $(".sphx-glr-download-link-note.admonition.note");
	  if (downloadNote.length >= 1) {
	      var tutorialUrl = $("#tutorial-type").text();
	      var githubLink = "https://github.com/pytorch/audio/blob/main/examples/"  + tutorialUrl + ".py",
		  notebookLink = $(".reference.download")[1].href,
		  notebookDownloadPath = notebookLink.split('_downloads')[1],
		  colabLink = "https://colab.research.google.com/github/pytorch/audio/blob/gh-pages/main/_downloads" + notebookDownloadPath;

	      $(".pytorch-call-to-action-links a[data-response='Run in Google Colab']").attr("href", colabLink);
	      $(".pytorch-call-to-action-links a[data-response='View on Github']").attr("href", githubLink);
	  }

          var overwrite = function(_) {
              if ($(this).length > 0) {
                  $(this)[0].href = "https://github.com/pytorch/audio"
              }
          }
          // PC
          $(".main-menu a:contains('GitHub')").each(overwrite);
          // Mobile
          $(".main-menu a:contains('Github')").each(overwrite);
      });

      
       $(window).ready(function() {
           var original = window.sideMenus.bind;
           var startup = true;
           window.sideMenus.bind = function() {
               original();
               if (startup) {
                   $("#pytorch-right-menu a.reference.internal").each(function(i) {
                       if (this.classList.contains("not-expanded")) {
                           this.nextElementSibling.style.display = "block";
                           this.classList.remove("not-expanded");
                           this.classList.add("expanded");
                       }
                   });
                   startup = false;
               }
           };
       });
    </script>

    


  <!-- Begin Footer -->

  <div class="container-fluid docs-tutorials-resources" id="docs-tutorials-resources">
    <div class="container">
      <div class="row">
        <div class="col-md-4 text-center">
          <h2>Docs</h2>
          <p>Access comprehensive developer documentation for PyTorch</p>
          <a class="with-right-arrow" href="https://pytorch.org/docs/stable/index.html">View Docs</a>
        </div>

        <div class="col-md-4 text-center">
          <h2>Tutorials</h2>
          <p>Get in-depth tutorials for beginners and advanced developers</p>
          <a class="with-right-arrow" href="https://pytorch.org/tutorials">View Tutorials</a>
        </div>

        <div class="col-md-4 text-center">
          <h2>Resources</h2>
          <p>Find development resources and get your questions answered</p>
          <a class="with-right-arrow" href="https://pytorch.org/resources">View Resources</a>
        </div>
      </div>
    </div>
  </div>

  <footer class="site-footer">
    <div class="container footer-container">
      <div class="footer-logo-wrapper">
        <a href="https://pytorch.org/" class="footer-logo"></a>
      </div>

      <div class="footer-links-wrapper">
        <div class="footer-links-col">
          <ul>
            <li class="list-title"><a href="https://pytorch.org/">PyTorch</a></li>
            <li><a href="https://pytorch.org/get-started">Get Started</a></li>
            <li><a href="https://pytorch.org/features">Features</a></li>
            <li><a href="https://pytorch.org/ecosystem">Ecosystem</a></li>
            <li><a href="https://pytorch.org/blog/">Blog</a></li>
            <li><a href="https://github.com/pytorch/pytorch/blob/master/CONTRIBUTING.md">Contributing</a></li>
          </ul>
        </div>

        <div class="footer-links-col">
          <ul>
            <li class="list-title"><a href="https://pytorch.org/resources">Resources</a></li>
            <li><a href="https://pytorch.org/tutorials">Tutorials</a></li>
            <li><a href="https://pytorch.org/docs/stable/index.html">Docs</a></li>
            <li><a href="https://discuss.pytorch.org" target="_blank">Discuss</a></li>
            <li><a href="https://github.com/pytorch/pytorch/issues" target="_blank">Github Issues</a></li>
            <li><a href="https://pytorch.org/assets/brand-guidelines/PyTorch-Brand-Guidelines.pdf" target="_blank">Brand Guidelines</a></li>
          </ul>
        </div>

        <div class="footer-links-col">
          <ul>
            <li class="list-title">Stay up to date</li>
            <li><a href="https://www.facebook.com/pytorch" target="_blank">Facebook</a></li>
            <li><a href="https://twitter.com/pytorch" target="_blank">Twitter</a></li>
            <li><a href="https://www.youtube.com/pytorch" target="_blank">YouTube</a></li>
            <li><a href="https://www.linkedin.com/company/pytorch" target="_blank">LinkedIn</a></li>
          </ul>  
          </div>

        <div class="footer-links-col">
          <ul>
            <li class="list-title">PyTorch Podcasts</li>
            <li><a href="https://open.spotify.com/show/6UzHKeiy368jKfQMKKvJY5" target="_blank">Spotify</a></li>
            <li><a href="https://podcasts.apple.com/us/podcast/pytorch-developer-podcast/id1566080008" target="_blank">Apple</a></li>
            <li><a href="https://www.google.com/podcasts?feed=aHR0cHM6Ly9mZWVkcy5zaW1wbGVjYXN0LmNvbS9PQjVGa0lsOA%3D%3D" target="_blank">Google</a></li>
            <li><a href="https://music.amazon.com/podcasts/7a4e6f0e-26c2-49e9-a478-41bd244197d0/PyTorch-Developer-Podcast?" target="_blank">Amazon</a></li>
          </ul>
         </div>
        </div>
        
        <div class="privacy-policy">
          <ul>
            <li class="privacy-policy-links"><a href="https://www.linuxfoundation.org/terms/" target="_blank">Terms</a></li>
            <li class="privacy-policy-links">|</li>
            <li class="privacy-policy-links"><a href="https://www.linuxfoundation.org/privacy-policy/" target="_blank">Privacy</a></li>
          </ul>
        </div>
        <div class="copyright">
        <p>Â© Copyright The Linux Foundation. The PyTorch Foundation is a project of The Linux Foundation.
          For web site terms of use, trademark policy and other policies applicable to The PyTorch Foundation please see
          <a href="www.linuxfoundation.org/policies/">www.linuxfoundation.org/policies/</a>. The PyTorch Foundation supports the PyTorch open source
          project, which has been established as PyTorch Project a Series of LF Projects, LLC. For policies applicable to the PyTorch Project a Series of LF Projects, LLC,
          please see <a href="www.lfprojects.org/policies/">www.lfprojects.org/policies/</a>.</p>
      </div>
     </div>

  </footer>

  <div class="cookie-banner-wrapper">
  <div class="container">
    <p class="gdpr-notice">To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or navigating, you agree to allow our usage of cookies. As the current maintainers of this site, Facebookâ€™s Cookies Policy applies. Learn more, including about available controls: <a href="https://www.facebook.com/policies/cookies/">Cookies Policy</a>.</p>
    <img class="close-button" src="../../../_static/images/pytorch-x.svg">
  </div>
</div>

  <!-- End Footer -->

  <!-- Begin Mobile Menu -->

  <div class="mobile-main-menu">
    <div class="container-fluid">
      <div class="container">
        <div class="mobile-main-menu-header-container">
          <a class="header-logo" href="https://pytorch.org/" aria-label="PyTorch"></a>
          <a class="main-menu-close-button" href="#" data-behavior="close-mobile-menu"></a>
        </div>
      </div>
    </div>

    <div class="mobile-main-menu-links-container">
      <div class="main-menu">
        <ul>
          <li>
            <a href="https://pytorch.org/get-started">Get Started</a>
          </li>

          <li>
            <a href="https://pytorch.org/ecosystem">Ecosystem</a>
          </li>
            
          <li>
            <a href="https://pytorch.org/mobile">Mobile</a>
          </li>

          <li>
            <a href="https://pytorch.org/blog/">Blog</a>
          </li>

          <li>
            <a href="https://pytorch.org/tutorials">Tutorials</a>
          </li>

          <li class="resources-mobile-menu-title">
            Docs
          </li>

          <ul class="resources-mobile-menu-items">
            <li>
              <a href="https://pytorch.org/docs/stable/index.html">PyTorch</a>
            </li>

            <li>
              <a href="https://pytorch.org/audio/stable/index.html">torchaudio</a>
            </li>

            <li>
              <a href="https://pytorch.org/text/stable/index.html">torchtext</a>
            </li>

            <li>
              <a href="https://pytorch.org/vision/stable/index.html">torchvision</a>
            </li>

            <li>
              <a href="https://pytorch.org/torcharrow">torcharrow</a>
            </li>

            <li>
              <a href="https://pytorch.org/data">TorchData</a>
            </li>

            <li>
              <a href="https://pytorch.org/torchrec">TorchRec</a>
            </li>

            <li>
              <a href="https://pytorch.org/serve/">TorchServe</a>
            </li>

            <li>
              <a href="https://pytorch.org/torchx/">TorchX</a>
            </li>

            <li>
              <a href="https://pytorch.org/xla">PyTorch on XLA Devices</a>
            </li>
          </ul>

          <li class="resources-mobile-menu-title">
            Resources
          </li>
            
           <ul class="resources-mobile-menu-items">

            <li>
              <a href="https://pytorch.org/features">About</a>
            </li>

            <li>
              <a href="https://pytorch.org/foundation">PyTorch Foundation</a>
            </li>

            <li>
              <a href="https://pytorch.org/#community-module">Community</a>
            </li>

            <li>
              <a href="https://pytorch.org/community-stories">Community Stories</a>
            </li>

            <li>
              <a href="https://pytorch.org/resources">Developer Resources</a>
            </li>

            <li>
              <a href="https://pytorch.org/events">Events</a>
            </li>

            <li>
              <a href="https://discuss.pytorch.org/">Forums</a>
            </li>

            <li>
              <a href="https://pytorch.org/hub">Models (Beta)</a>
            </li>
          </ul>

          <li>
            <a href="https://github.com/pytorch/pytorch">Github</a>
          </li>
        </ul>
      </div>
    </div>
  </div>

  <!-- End Mobile Menu -->

  <script type="text/javascript" src="../../../_static/js/vendor/anchor.min.js"></script>

  <script type="text/javascript">
    $(document).ready(function() {
      mobileMenu.bind();
      mobileTOC.bind();
      pytorchAnchors.bind();
      sideMenus.bind();
      scrollToAnchor.bind();
      highlightNavigation.bind();
      mainMenuDropdown.bind();
      filterTags.bind();

      // Add class to links that have code blocks, since we cannot create links in code blocks
      $("article.pytorch-article a span.pre").each(function(e) {
        $(this).closest("a").addClass("has-code");
      });
    })
  </script>
</body>
</html>